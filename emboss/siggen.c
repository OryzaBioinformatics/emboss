/* @source siggen application
**
** Signature generating program
** @author: Copyright (C) Matt Blades (mblades@hgmp.mrc.ac.uk)
** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
** @@
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
******************************************************************************
** 
** 
** 
** 
** 
** 
** Operation
** 
** Siggen parses a multiple structure alignment generated by the EMBOSS 
** application scopalign and corresponding files of residue contact data 
** generated by the EMBOSS application contacts and generates a protein 
** signature of a specified sparsity.
**
** Each position in the alignment is scored on the basis of a single or any 
** combination of up to 3 scoring schemes.  A signature of, for example, 10% 
** sparsity would include data from the top 10% highest scoring alignment 
** positions.
**
** 
** The output file (Figure 1) uses the following records 
** The four SCOP classification records are taken from the alignment input file: 
** (1)  CL - Domain class.  It is identical to the text given after 'Class' in 
** the scop classification file (see documentation for the EMBOSS application 
** scope). 
** (2)  FO - Domain fold.  It is identical to the text given after 'Fold' in 
** the scop classification file (see scope documentation). 
** (3)  SF - Domain superfamily.  It is identical to the text given after 
** 'Superfamily' in the scop classification file (see scope documentation). 
** (4)  FA - Domain family. It is identical to the text given after 'Family' in 
** the scop classification file (see scope documentation). 
** (5)  NP - Number of signature positions.
** (6)  NN - Signature position number.  The number given in brackets after 
** this record indicates the start of the data for the relevent signature position.
** (7)  IN - Informative line about signature position. The number of different 
** amino acid residues seen for this position is given after 'NRES', the number 
** of different sizes of gap follows 'NGAP', and the window size after 'WSIZ'.
** When a signature is aligned to a protein sequence, the permissible gaps between 
** two signature positions is determined by the empirical gaps and the window 
** size for the C-terminal position (see sigscan.c)
** Two rows of data for the emprical residues and gaps are then given:
** (8)  AA - The identifier of a residue seen in this position and the frequency 
** of its occurence are delimited by ';'.
** (9)  GA - The size of a gap seen in this position and the frequency 
** of its occurence are delimited by ';'.
** (10) // - used to delimit data for each signature. The last line of a file 
** always  contains '//' only.
** 
**
** Figure 1   Excerpt from a signature file
**
**  CL   All beta proteins
**  XX
**  FO   Lipocalins
**  XX
**  SF   Lipocalins
**  XX
**  FA   Fatty acid binding protein-like
**  XX
**  NP   2
**  XX
**  NN   [1] 
**  XX
**  IN   NRES 3 ; NGAP 2 ; WSIZ 2  
**  XX
**  AA   A ; 2
**  AA   V ; 1
**  AA   L ; 4
**  XX
**  GA   1 ; 5
**  GA   2 ; 2
**  XX
**  NN   [2] 
**  XX
**  IN   NRES 2 ; NGAP 2 ; WSIZ 5  
**  XX
**  AA   F ; 1
**  AA   Y ; 5
**  XX
**  GA   12 ; 3
**  GA   10 ; 2
**  XX
**  //
** 
** Important
** 1. In the case a signature file is generated by hand, it is essential that the 
** gap data given is listed in order of increasing gap size.  
** 2. In the current implementation, window size records always have the value
** of 0. These should be changed manually unless a very rigid pattern is required. 
** A future implementation will provide a range of methods for generating values
** of window size depending upon the alignment (window size is identified by the 
** WSIZ record in the signature output file).
** 3. Siggen presumes that standard SCOP domain identifiers are given in the input 
** alignment  if the id is 7 characters long and the first character is a 'd' or 'D'. 
** In this case the contact data for that chain will be parsed. Otherwise contact 
** data for chain 1 will be parsed.
**
**  
** Notes
** Should describe scoring schemes in above.
**
******************************************************************************/







#include <math.h>

#include "emboss.h"

AjBool  siggen_ScoreSeq(AjPScopalg alg, AjPScorealg *scores, AjPMatrixf mat, 
			AjPInt2d seq_pos);
AjBool  siggen_ScoreNcon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
			 AjPInt2d seq_pos);
AjBool  siggen_ScoreCcon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
			 AjPInt2d seq_pos);
AjBool  siggen_ScoreNCCon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps,  
			  AjPInt2d seq_pos);
AjBool  siggen_ScoreCombined(AjPScorealg *scores);
AjPSignature  siggen_SigSelect(AjPScopalg alg, AjPScorealg scores, 
			       AjPInt2d seq_pos, ajint sig_sparse);
AjBool siggen_CalcSeqpos(AjPScopalg alg, AjPInt2d *seq_pos);
AjBool siggen_ScoreAlignment(AjPScorealg *scores, AjPScopalg alg, AjPCmap *cmaps, 
			     AjPMatrixf  mat, AjPInt2d seq_pos);






/* @prog siggen *************************************************************
**
** Signature generating program
**
******************************************************************************/

int main(ajint argc, char **argv)
{
    /* Variables for stuff in acd */
    AjPStr      alg_path      =NULL;    /* Location of alignment files for input */
    AjPStr      alg_extn      =NULL;    /* Extn. of alignment files */
    AjPStr      alg_name      =NULL;    /* Name of alignment file */
    AjPStr      con_path      =NULL;    /* Location of contact files for input */
    AjPStr      con_extn      =NULL;    /* Extn. of contact files */
    AjPStr      con_name      =NULL;    /* Name of contact file */
    AjPStr      pair_mat      =NULL;    /* Residue pair substitution matrix */
    AjPStr      temp          =NULL;    /* Temp string */

    AjPFile     fptr_alg      =NULL;    /* Pointer to alignment file */
    AjPFile     fptr_con      =NULL;    /* Pointer to current contact file */
    AjPFile     sig_outf      =NULL;    /* File pointer for output file */

    AjPList     list          =NULL;    /* List of files in alignment directory */   
    AjPMatrixf  mat           =NULL;
    AjPInt2d    seq_pos       =NULL;    /* Numbering of sequence according to alignment */

    AjPSignature sig=NULL;              /*Signature*/
    AjPScopalg  alg           =NULL;    /* Pointer to Scopalg structure */
    AjPScorealg scores        =NULL;    /* Pointer to Scorealg structure */
    AjPCmap    *cmaps         =NULL;    /* Array of pointers to Cmap structures */

    AjBool      random        =ajFalse; /* Generate random signature (Y/N) */
    AjBool      score_seq     =ajTrue;  /* Score on basis of residue conservation  (Y/N) */ 
    AjBool      filter        =ajTrue;  /* Filter on basis of post_similar data line (Y/N) */ 
    AjBool      score_ncon    =ajTrue;  /* Score on basis of number of contacts  (Y/N) */ 
    AjBool      score_ccon    =ajTrue;  /* Score on basis of conservation of contacts  (Y/N) */
    AjBool      score_both    =ajTrue;  /* Score on basis of number and conservation (Y/N) */ 

    char        id            ='.';     /* Chain identifier for a scop domain*/
    ajint       x             =0;       /* Loop counter */
    ajint       sig_sparse    =0;       /* Sparsity of signature */
    
    

    

    /* Allocate strings etc */
    alg_path      = ajStrNew();
    alg_extn      = ajStrNew();
    alg_name      = ajStrNew();
    con_path      = ajStrNew();
    con_extn      = ajStrNew();
    con_name      = ajStrNew();
    pair_mat      = ajStrNew();
    temp          = ajStrNew();
    

    /* Read data from acd */
    embInit("siggen",argc,argv); 
    alg_path     = ajAcdGetString("algpath");
    alg_extn     = ajAcdGetString("algextn");    
    con_path     = ajAcdGetString("conpath");    
    con_extn     = ajAcdGetString("conextn");    
    sig_sparse   = ajAcdGetInt("sparsity");
    random       = ajAcdGetBool("randomize");
    score_seq    = ajAcdGetBool("scoreseq");
    filter       = ajAcdGetBool("postsim");
    score_ncon   = ajAcdGetBool("scorencon");
    score_ccon   = ajAcdGetBool("scoreccon");
    score_both   = ajAcdGetBool("scoreboth");
    sig_outf     = ajAcdGetOutfile("sigfile");    
    mat          = ajAcdGetMatrixf("datafile");

    
    /* Check directories*/
    if(!ajFileDir(&alg_path))
        ajFatal("Could not open alignments directory");
    if(!ajFileDir(&con_path))
        ajFatal("Could not open contacts directory");

    
    /* Check if a scoring method has been selected */
    if((score_seq == ajFalse) && (score_ncon == ajFalse) && 
       (score_ccon == ajFalse))
    {
        ajFmtPrint("No scoring methods were selected. Exiting\n");
        ajExit();
        return 0;
    }	


    /* Create list of files in alignments directory */
    list = ajListNew();
    ajStrAssC(&temp, "*");      
    if((ajStrChar(alg_extn, 0)=='.'))
        ajStrApp(&temp, alg_extn);    
    else
    {
        ajStrAppC(&temp, ".");    
        ajStrApp(&temp, alg_extn);    
    }
    ajFileScan(alg_path, temp, &list, ajFalse, ajFalse, 
	       NULL, NULL, ajFalse, NULL); 


    ajStrDel(&temp);

    /*Start of main application loop*/
    while(ajListPop(list,(void **)&temp))
    {
        /* Open alignment file */
        if((fptr_alg=ajFileNewIn(temp))==NULL)
        {
            ajFileClose(&fptr_alg);
            ajWarn("Could not open alignment file");
	    ajStrDel(&temp);
            continue;       
        }


        /* Read alignment file, write Scopalgn structure, 
	   close alignment file */
        ajXyzScopalgRead(fptr_alg, &alg);
	ajFileClose(&fptr_alg);
	

        /* Allocate array of pointers to Cmap structures for contact maps */
        AJCNEW0(cmaps, alg->N);

        
        /* Start of loop for reading contact data */
        for(x=0; x<alg->N; ++x)
        {
            /* Get name of contact data file */
            ajStrAss(&temp, con_path);
            ajStrApp(&temp, alg->Codes[x]);
            if((ajStrChar(con_extn, 0)=='.'))
                ajStrApp(&temp, con_extn);    
            else
            {
                ajStrAppC(&temp, ".");    
                ajStrApp(&temp, con_extn);    
            }       


            /* Open contact data file */
            if((fptr_con=ajFileNewIn(temp))==NULL)
            {
                ajFileClose(&fptr_con);
                ajWarn("Could not open contact file");
                continue;           
            }   


            /* Read contact data file; hard-coded to read model 1 
	       from file */
	    /* A scop identifier is presumed if the id is 7 characters 
	       long and the first character is a 'd' or 'D' */
	    if((ajStrLen(alg->Codes[x])==7)
	       &&(toupper(ajStrChar(alg->Codes[x], 0)) == 'D'))
	    { 
		/*Read the chain id from the SCOP domain code and convert 
		  cases of '_' identifiers to '.' */
		id=ajStrChar(alg->Codes[x], 5);
		if(id=='_') id='.';
		
		ajXyzCmapReadC(fptr_con, id, 1, &cmaps[x]);
	    }
            else  
		/*Not sure of a chain identifier so read the first chain*/
		    ajXyzCmapReadI(fptr_con, 1,1, &cmaps[x]);


            /* Close contact data file */
            ajFileClose(&fptr_con);
        }


        /* Allocate Scorealg structure and write values from acd */
        scores = ajXyzScorealgNew((ajint)alg->width);
        scores->seq_do = score_seq;
        scores->filter = filter;
        scores->ncon_do = score_ncon;
        scores->ccon_do = score_ccon;
        scores->nccon_do = score_both;


	/*Calculate index for use by scoring functions */
	siggen_CalcSeqpos(alg, &seq_pos);
	

	/* Score alignement - write Scorealg structure */
	siggen_ScoreAlignment(&scores, alg, cmaps, mat, seq_pos);


	/* Generate signature */
	sig = siggen_SigSelect(alg, scores, seq_pos, sig_sparse);


	/* Write signature file*/
	if(!ajXyzSignatureWrite(sig_outf, sig))
	    ajFatal("Error writing signature file");
	

        /* Free memory */
	ajXyzSignatureDel(&sig);
        for(x=0; x<alg->N; ++x)
            ajXyzCmapDel(&cmaps[x]);
        AJFREE(cmaps);
        ajXyzScorealgDel(&scores); 
	ajXyzScopalgDel(&alg);

	ajStrDel(&temp);
    }

 



    /*Tidy up */
    ajStrDel(&alg_path);
    ajStrDel(&alg_extn);
    ajStrDel(&alg_name);
    ajStrDel(&con_path);
    ajStrDel(&con_extn);
    ajStrDel(&con_name);
    ajStrDel(&pair_mat);

    ajFileClose(&fptr_alg);
    ajFileClose(&fptr_con);
    ajFileClose(&sig_outf);

    ajListDel(&list);
    ajMatrixfDel(&mat);
    ajInt2dDel(&seq_pos);    


    /* Return */
    ajExit();
    return 0;
}





/* @func siggen_ScoreSeq ****************************************************
 **
 ** Reada a Scopalg object and writes a Scorealg object. Each residue in 
 ** the alignment is scored on the basis of conservation of residue type.
 **
 **
 ** @param [r] alg     [AjPScopalg]   Alignment
 ** @param [w] scores  [AjPScorealg*] Scores for alignment
 ** @param [r] mat     [AjPMatrixf]   Subsitution matrix
 ** @param [r] seq_pos [AjPInt2d]     Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ****************************************************************************/
AjBool  siggen_ScoreSeq(AjPScopalg alg, AjPScorealg *scores, AjPMatrixf mat, 
		 AjPInt2d seq_pos)
{
    ajint       memb_cnt     =0;    /* Counter for members of the family (alignment) */
    ajint       res_cnt      =0;    /* Counter for residue in the alignment */
    ajint       post_cnt     =0;    /* Counter for post_similar line */
    float       **sub        =0;    /* Array of floats for sub matrix */
    float       val          =0;    /* Current value for res sub score */        
    float       pos_score    =0;    /* Total sub score for all res at position */
    float       temp         =0;    /* Temp variable for score */
    AjPSeqCvt   cvt          =0;    /* variable for sequence character conversion table */





    cvt = ajMatrixfCvt(mat);        /* Create sequence character conversion table */
    sub = ajMatrixfArray(mat);      /* Create matrix as array of floats */
    

    /* Counter for positions in alignment */
    for(post_cnt = 0; post_cnt < alg->width; post_cnt++)
    {
        /* Filter on basis of post_similar line*/
        if((((*scores)->filter) 
	    && (ajStrChar(alg->Post_similar, post_cnt) == '1')) ||
	   ((*scores)->filter == ajFalse))
        {
            /* Initialise variable to zero */
            val = 0;
            pos_score = 0;
            temp = 0;

            /* Iterate through member of family */
            for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
            {   
		if(ajStrChar(alg->Seqs[memb_cnt], post_cnt)=='-')
		    continue;

		
                /* Iterate throught every combination of residues */
                /* at the current position */
                for(res_cnt = (memb_cnt+1); res_cnt < alg->N; res_cnt++)
                    {
			if(ajStrChar(alg->Seqs[res_cnt], post_cnt)=='-')
			    continue;


                        /* Assign score form matrix to variable val */
                        val = (sub[ajSeqCvtK(cvt, (ajStrChar(alg->Seqs[memb_cnt], 
			    post_cnt)))][ajSeqCvtK(cvt, 
			    (ajStrChar(alg->Seqs[res_cnt], post_cnt)))]);


                        /* Add score form matrix to temp */
                        temp += val;

                    }
            }
            /* Perform last part of calculation */
            /* Divide total score by members in family */
            pos_score = (temp/alg->N);


            /* Assign total score for substitution of all the residues */
            /* at a position into scoring array                         */
            ajFloatPut(&(*scores)->seq_score, post_cnt, pos_score);
        }
    }

 
    /* Return */
    return ajTrue;
}





/* @func siggen_ScoreNcon *****************************************************
 **
 ** Reada a Scopalg object and writes a Scorealg object. Each residue in 
 ** the alignment is scored on the basis of the number of phsyical contacts
 ** (residue-residue) it makes in the structure. Contacts are read from a
 ** Cmaps object.
 **
 ** @param [r] alg     [AjPScopalg ]    Alignment
 ** @param [w] scores  [AjPScorealg*]   Scores for alignment
 ** @param [r] cmaps   [AjPCmap*]       Residue contacts
 ** @param [r] seq_pos [AjPInt2d]       Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
AjBool  siggen_ScoreNcon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
			 AjPInt2d seq_pos)
{

    ajint       memb_cnt     =0;    /* Counter for members of the family (alignment) */
    ajint       xmat_cnt     =0;    /* Counter for x axis of contact matrix */
    ajint       ymat_cnt     =0;    /* Counter for y axis of contact matrix */
    ajint       nconcount    =0;    /* Counter for number of contacts at position*/
    ajint       x            =0;    /* Counter for initializing arrays to zero */
    ajint       post_cnt     =0;    /* Counter for post_similar line */
    ajint       nconpos_cnt  =0;    /* Counter to hold ncon */
    ajint       idx          =0;    /* Index into seq_pos array */
    float       av_ncon      =0;    /* Counter to hold average no. of contacts */
    AjIStr      iter         =NULL; /* Iterator for post_similar string */
    AjPInt2d    align_ncon   =NULL; /* Matrix of number of contacts for every residue */

    
    



    /* Allocate memory for the align_ncon array  */
    align_ncon = ajInt2dNewL((ajint)alg->width);        


    /* Assign iterator for post_similar line */
    iter = ajStrIter(alg->Post_similar);


    /* Create arrays of size width */
    for(x = 0; x < alg->N; x++)
        ajInt2dPut(&align_ncon, x, alg->width-1, (ajint) 0);


    /* Determine ncon value for every residue */
    /* Counter for sequences in alignment */
    for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {
        /* Counter for x-axis of contact map */
        for(xmat_cnt = 0; xmat_cnt < cmaps[memb_cnt]->Dim; xmat_cnt++)
        {
            /* Counter for y-axis of contact map */
            for(ymat_cnt = 0; ymat_cnt < cmaps[memb_cnt]->Dim; ymat_cnt++)
            {
                /* Check if position in contact map is 1 (i.e. contact) */
                if(ajInt2dGet(cmaps[memb_cnt]->Mat, xmat_cnt, ymat_cnt) == 1)
                {
                    /* Increment ncon counter */
                    nconcount++;
                }
            }
        /* Put nconcounter value into array */
        ajInt2dPut(&align_ncon, memb_cnt, xmat_cnt, nconcount);
        nconcount = 0;
        }
    }
    

    /* Counter for positions in alignment */
    for(post_cnt = 0; post_cnt < alg->width; post_cnt++)
    {
        if((((*scores)->filter) && 
	    (ajStrChar(alg->Post_similar, post_cnt) == '1'))  ||
	   ((*scores)->filter == ajFalse))
        {
            /* Extract ncon for residues in alignment at that position */
            for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
            {
		/*Check to see if alignment position is a gap*/
		if((idx=ajInt2dGet(seq_pos, memb_cnt, post_cnt))==-1)
		    continue;
		else		
		    nconpos_cnt += ajInt2dGet(align_ncon, memb_cnt, idx);
            }


            /* Divide total ncon at the position by no. of */
            /* sequences in alignment */
            av_ncon = (float)nconpos_cnt/(float)alg->N;
            nconpos_cnt = 0;


            /* Assign av. ncon value for residues at that position into */
            /* ncon_score array of scores structure at position */
            /* corresponding to alignment */
            ajFloatPut(&(*scores)->ncon_score, post_cnt, av_ncon);
        }
    }


    /* Free memory for matrix and iterator */
    ajInt2dDel(&align_ncon);
    ajStrIterFree(&iter);


    /* Return */
    return ajTrue;
}





/* @func siggen_ScoreCcon *****************************************************
 **
 ** Reada a Scopalg object and writes a Scorealg object. Each residue in 
 ** the alignment is scored on the basis of the conservation of phsyical 
 ** contacts (residue-residue) it makes in the structures. Contacts are 
 ** read from a Cmaps object.
 **
 ** @param [r] alg     [AjPScopalg ]    Alignment
 ** @param [w] scores  [AjPScorealg*]   Scores for alignment
 ** @param [r] cmaps   [AjPCmap*]       Residue contacts
 ** @param [r] seq_pos [AjPInt2d]       Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
AjBool  siggen_ScoreCcon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps, 
		  AjPInt2d seq_pos)
{
    ajint       memb_cnt     =0;    /* Counter for members of the family (alignment) */
    ajint       post_cnt     =0;    /* Counter for post_similar line */
    ajint       y_cnt        =0;    /* Counter for y axis of contact matrix */
    ajint       seqpos_cnt   =0;    /* Counter for position in alignment */
    ajint       nsite        =0;    /* Number of sites with oarticular contact */
    ajint       x            =0;    /* Counter */
    ajint       temp         =0;    /* Current position of seq_pos array */
    ajint       num          =0;    /* Assign to each element of con_contacts */
    ajint       p            =0;
    ajint       idx          =0;    /* Index */
    float       sum          =0;    /* Variable to hold nsite calculation */
    AjIStr      iter         =NULL; /* Iterator for post_similar string */
    AjPInt2d    con_contact  =NULL; /* Matrix of conserv of contacts for every residue */
    AjPInt      con_line     =NULL; /* Temp storage of line */
    



    
    /*Allocate memory for the con_contac array  */
    con_contact    = ajInt2dNewL((ajint)alg->width);    
    con_line       = ajIntNewL((ajint)alg->width);

    
    /* Assign iterator for post_similar line */
    iter = ajStrIter(alg->Post_similar);
    
    
    /* Create arrays of size width */
    for(x = 0; x < alg->width; x++)
        ajInt2dPut(&con_contact, x, alg->width-1, 0);


    /* Create arrays of size width */
    ajIntPut(&con_line, alg->width-1, 0);


    /* Start of main loop */
    /* Iterate through Post_similar line */
    for(post_cnt = 0; post_cnt < alg->width; post_cnt++)
    {
        /*Check if post_similar line is '1' */
        if((((*scores)->filter) && 
	    (ajStrChar(alg->Post_similar, post_cnt) == '1'))  ||
	   ((*scores)->filter == ajFalse))
        {
            /* Create array of size width */
            for(x = 0; x < alg->width; x++)
                ajIntPut(&con_line, x, 0); 
            nsite = 0;
            num = 0;


            /* Perform calculation for each member of family */
            for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
            {   
		/* Go through each element of cmap column */
                for(y_cnt = 0; y_cnt < cmaps[memb_cnt]->Dim; y_cnt++)
                {
		    /*Check to see if alignment position is a gap*/
		    if((idx=ajInt2dGet(seq_pos,memb_cnt,post_cnt))==-1)
			continue; 


                    /*Check if position in contact map is 1 (i.e. contact) */
                    if(ajInt2dGet(cmaps[memb_cnt]->Mat,idx,y_cnt)==1)
                    {
                        /*Determine position of y_cnt in seq_pos array */
                        for (seqpos_cnt=0; seqpos_cnt<alg->width; seqpos_cnt++)
                        {
			    /*Check to see if alignment position is a gap*/
			    if((idx=ajInt2dGet(seq_pos, memb_cnt, seqpos_cnt))==-1)
				continue;

			    
                            /* Find position where value of y_cnt appears */
                            if(idx == y_cnt)
                                {
                                    /* Assign current value of seq_pos to temp */
                                    temp = idx;
				

                                    if(ajIntGet(con_line, temp) == 0)
                                        nsite++;
                                    /* Increment element of con_line */
                                    ajIntInc(&con_line, (ajint) temp);


                                    ajInt2dPut(&con_contact, post_cnt, idx, 
					       (ajIntGet(con_line, idx)));
                                    break;
                                }
                        }
		    }
		}
            }
            sum = 0;
            for(p = 0; p < alg->width; p++)
                if(ajIntGet(con_line, p)!=0)
                    sum += ((float)(ajIntGet(con_line, p)/((float)(ajint)alg->N)));
            
	    
            /* Write total sum for all residues at position post_cnt*/
            /* into scores structure */ 
            ajFloatPut(&(*scores)->ccon_score, post_cnt, (sum/(float)nsite));
        }
    }



    

    /* Free memory for matrix and iterator */
    ajIntDel(&con_line);
    ajInt2dDel(&con_contact);
    ajStrIterFree(&iter);


    /* Return */
    return ajTrue;
}






/* @func siggen_ScoreNCCon ****************************************************
 **
 ** Reada a Scopalg object and writes a Scorealg object. Each residue in 
 ** the alignment is scored on the basis of a combination of the the number 
 ** and conservation of phsyical contacts (residue-residue) it makes in the 
 ** structure. Contacts are read from a Cmaps object.
 ** 
 ** @param [r] alg     [AjPScopalg ]    Alignment
 ** @param [w] scores  [AjPScorealg*]   Scores for alignment
 ** @param [r] cmaps   [AjPCmap*]       Residue contacts
 ** @param [r] seq_pos [AjPInt2d]       Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
AjBool  siggen_ScoreNCCon(AjPScopalg alg, AjPScorealg *scores, AjPCmap *cmaps,  
		   AjPInt2d seq_pos)
{
    /*JC added to stop make bitching */
    return ajFalse;
}





/* @func siggen_ScoreCombined *****************************************************
 **
 ** Read the Scorealg structure and calculates the combined scores for 
 ** each structurally equivalent residue in the alignment.
 ** 
 **
 ** @param [w] scores  [AjPScorealg*] Scorealg object
 **
 ** @return [AjBool] True on succcess
 ** @@
 *****************************************************************************/
AjBool  siggen_ScoreCombined(AjPScorealg *scores)
{
    /*JC added to stop make bitching */
    return ajFalse;
}





/* @func siggen_SigSelect *************************************************
 **
 ** Read Scopalg and Scorealg objects and returns a pointer to a Signature
 ** object. The signature generated is derived from a number, determined
 ** by the sparsity of the signature, of the top-scoring positions in the 
 ** alignment
 **
 ** @param [r] alg        [AjPScopalg]  Alignment 
 ** @param [r] scores     [AjPScorealg] Scores for alignment
 ** @param [r] seq_pos    [AjPInt2d]    Index for alignment
 ** @param [r] sig_sparse [ajint]       Sparsity of signature
 **
 ** @return [AjPSignature] Pointer to Signature structure or NULL on failure
 ** @@
 *****************************************************************************/
AjPSignature  siggen_SigSelect(AjPScopalg alg, AjPScorealg scores, 
			       AjPInt2d seq_pos, ajint sig_sparse)
{
    ajint       nseqs=0; /*Number of sequences*/
    ajint       idx              =0;   /*Index*/
    ajint       cnt              =0;    /* Counter for post_similar line */
    ajint       first            =0;    /* Counter */
    ajint       x                =0;    /* Counter */
    ajint       memb_cnt         =0;    /* Counter */
    ajint       j                =0;    /* Counter */
    ajint       i                =0;    /* Counter */
    ajint       imax             =0;    /* Loop exit condition */
    ajint       hold_pos         =0;    /* Counter to hold values whilst sorting */
    ajint       res_count        =0;    /* Counter for total number of residues */
    ajint       num_aligned      =0;    /* Number of positions scoring '1' in alignment */
    ajint       single_rescount  =0;
    ajint       gsiz             =0;    /* Temp. size of gap*/
    ajint       npos             =0;    /* Counter of signature positions*/
    ajint       sig_npos         =0;    /* Number of positions in signature */
    float       val              =0.0;   /*Temp. val*/
    float       seq_min          =0;    /* Variable for minimum seq subn score */
    float       seq_max          =0;    /* Variable for maximum seq subn score */
    float       ncon_min         =0;    /* Variable for minimum ncon score */
    float       ncon_max         =0;    /* Variable for maximum ncon score */
    float       ncon_temp        =0;    /* Variable for temp. ncon score */
    float       hold             =0;    /* Counter to hold values whilst sorting */
    AjBool      done             =ajFalse;  /*Flag*/
    AjPFloat    seq_normal       =NULL; /* Array of floats for normalised seq_score */
    AjPFloat    ncon_normal      =NULL; /* Array of floats for normalised ncon_score */
    AjPFloat    ccon_normal      =NULL; /* Array of floats for normalised ccon_score */
    AjPFloat    total_score      =NULL; /* Array of floats for total normalised scores */
    AjPInt      keyres_pos       =NULL; /* Total_score array, sorted in ascending order */
    AjPInt      post_sim         =NULL; /* Array for positions in post_similar line */
    AjPInt      seq_len          =NULL; /* Total_score array, sorted in ascending order */
    AjPInt2d    keyres_seq       =NULL; /* Total_score array, sorted in ascending order */
    AjPStr      *seq_array       =NULL; /* Arrays of sequence (w/o gaps) from alignment */
    AjPSignature sig=NULL;       /* Signature */

    



    /* Check args */
    if(!alg || !scores || !seq_pos || !sig_sparse)
    {
	ajWarn("Null args passed to siggen_SigSelect");
	return NULL;
    }
    

    /* Create arrays */
    seq_normal          =  ajFloatNewL(alg->width);
    ncon_normal         =  ajFloatNewL(alg->width);
    ccon_normal         =  ajFloatNewL(alg->width);
    total_score         =  ajFloatNewL(alg->width);
    keyres_pos          =  ajIntNewL(alg->width);    
    post_sim            =  ajIntNewL(alg->width);
    keyres_seq          =  ajInt2dNew();    
    seq_len             =  ajIntNewL(alg->N);    
    

    /* Initialise array elements to zero */
    ajFloatPut(&seq_normal, alg->width-1, (float) 0.0);
    ajFloatPut(&ncon_normal, alg->width-1, (float) 0.0);
    ajFloatPut(&ccon_normal, alg->width-1, (float) 0.0);
    ajFloatPut(&total_score, alg->width-1, (float) 0.0);
    ajIntPut(&keyres_pos, alg->width-1, (ajint) 0);
    ajIntPut(&post_sim, alg->width-1, (ajint) 0);


    nseqs=ajXyzScopalgGetseqs(alg, &seq_array);


    /* Start of main application loop */
    /* Determine min and max values of seq_score */
    /* Iterate through (scores)->seq_score array */
    if((scores)->seq_do == ajTrue)
    {
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Check if value is not zero */
            if(ajFloatGet((scores)->seq_score, cnt) != 0)
            {
                /* If in loop for first time assign min and ,ax */
                if(first == 0)
                {
                    seq_min = ajFloatGet((scores)->seq_score, cnt);
                    seq_max = ajFloatGet((scores)->seq_score, cnt);
                    first = 1;
                }


                /* Check if value is >, <, = to min/max */
                /* If true assign value to min/max variable */
                if(ajFloatGet((scores)->seq_score, cnt) < seq_min)
                    seq_min = ajFloatGet((scores)->seq_score, cnt);

                if(ajFloatGet((scores)->seq_score, cnt) == seq_min)
                    continue;
                if(ajFloatGet((scores)->seq_score, cnt) == seq_max)
                    continue;
                if(ajFloatGet((scores)->seq_score, cnt) > seq_max)
                    seq_max = ajFloatGet((scores)->seq_score, cnt);
            }
        }
    }


    /* Determine min and max values of ncon_score */
    /* Iterate through (scores)->ncon_score array */
    if((scores)->ncon_do == ajTrue)
    {
        first = 0;
        for(cnt =0; cnt <alg->width; cnt++)
        {
            /* Check if value is not zero */
            if(ajFloatGet((scores)->ncon_score, cnt) != 0)
            {
                /* If in loop for first time assign min and max */
                if(first == 0)
                {
                    ncon_min = ncon_max = ajFloatGet((scores)->ncon_score, cnt);

                    first = 1;
                }


		ncon_temp = ajFloatGet((scores)->ncon_score, cnt);
		if(ncon_temp < ncon_min)
                    ncon_min = ncon_temp;
		else if(ncon_temp > ncon_max)
                    ncon_max = ncon_temp;
            }
        }
    }
    


    /* Perform normalising calculation on seq_score array */
    if((scores)->seq_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)
	    /* Put normalised score into array at eqiuvalent position */
	    ajFloatPut(&seq_normal, cnt,((ajFloatGet((scores)->seq_score, cnt) 
					  - seq_min)/(seq_max - seq_min)));

    
    /* Perform normalising calculation on ncon_score array */
    if((scores)->ncon_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)
	    /* Put normalised score into array at eqiuvalent position */
	    ajFloatPut(&ncon_normal, cnt,((ajFloatGet((scores)->ncon_score, cnt) 
					   - ncon_min)/(ncon_max - ncon_min)));  


    /* Copying ccon_score array to ccon_normal */
    if((scores)->ccon_do == ajTrue)
        for(cnt =0; cnt <alg->width; cnt++)
	    /* Put normalised score into array at eqiuvalent position */
	    ajFloatPut(&ccon_normal, cnt,((ajFloatGet((scores)->ccon_score, 
						      cnt))));
    

    for(x=0; x<alg->width; x++)
    {
	val=0.0;
	if((scores)->seq_do == ajTrue) 
	    val+=ajFloatGet(seq_normal, x);
	if((scores)->ncon_do == ajTrue) 
	    val+=ajFloatGet(ncon_normal, x);
	if((scores)->ccon_do == ajTrue)
	    val+=ajFloatGet(ccon_normal, x);


	ajFloatPut(&total_score, x, val);
    }
    

    /* Initialise array elements from 0 to alg->width*/
    for(x=0; x<alg->width; x++)
    {
        ajIntPut(&post_sim, x, x);
        if((scores->filter) && (ajStrChar(alg->Post_similar, x) == '1'))
            num_aligned++;
    }    
    if(scores->filter == ajFalse)
	num_aligned = alg->width;
    

    /* Perform bubble sort of total_score array  */ 
    for(i=1; i<=(alg->width-1); i++)
        for(j=0; j<=(alg->width-2); j++)
        { 
            /* Check if element j is > than element j+1 */
            if((ajFloatGet(total_score, j)) > 
	       (ajFloatGet(total_score, (j + 1))))
            {
		/* Swap elements j and j+1 via hold/hold_pos variables */
                hold = ajFloatGet(total_score, j);
                hold_pos = ajIntGet(post_sim, j);
                ajFloatPut(&total_score, j, (ajFloatGet(total_score, (j+1))));
                ajIntPut(&post_sim, j, (ajIntGet(post_sim, (j+1))));
                ajFloatPut(&total_score, (j+1), hold);
                ajIntPut(&post_sim, (j+1), hold_pos);
            }           
        }


    /* Determine average number of residues for alignment */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {
        single_rescount = 0;
        for(i=0; i<alg->width; i++)
            if(ajStrChar(alg->Seqs[memb_cnt], i) != '-')
            {
                res_count++;
                single_rescount++;
            }
	ajIntPut(&seq_len, memb_cnt, single_rescount);
    }


    /* Initialise keyres_seq array to zero */
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)
            ajInt2dPut(&keyres_seq, memb_cnt, i, 0);
    
    
    /* Calculate the number of positions the signature should have */
    /* Determine no. of positions the signature will have */
    /* JC New way of calculating sig_npos */
    sig_npos = (ajint) ceil((double)  ((res_count/alg->N) * 
				       ( (float)sig_sparse/(float)100)));
    

    /* Check if the user entered sparsity exceeds */
    /* the number of positions which are aligned  */
    /* in the alignment                           */
    if(num_aligned < sig_npos)
    {
        /* If so print message */
        /* Generate signature using all of the aligned positions */
        /* scoring '1' */
        /* Begin at end i.e. highest scoring positions */
        /* of post_sim array */
        /* Count down from end until all '1' positions are */
        /* entered in keyres_pos array */
        for(i=alg->width-1; i>=alg->width-(num_aligned); i--)
        {
            /* Put a '1' in keyres_pos array at position */
            /* corresponding to position in post_sim array */
            ajIntPut(&keyres_pos, ajIntGet(post_sim, i), 1);
        }
    }
    

    /* Else output signature of sparsity specified by user */
    else
    {
        /* Begin at end i.e. highest scoring positions */
        /* of post_sim array */
        /* Count down from end until sparsity is fulfilled */
        for(i=alg->width-1; i>=alg->width-(sig_npos); i--)
        {
            /* Put a '1' in keyres_pos array at position */
            /* corresponding to position in post_sim array */
            ajIntPut(&keyres_pos, ajIntGet(post_sim, i), 1);
        }
    }    

    
    for(i=0; i<alg->width; i++)
    {
        if(ajIntGet(keyres_pos, i) == 1)
        {
            for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)            
	    {
		/*Check to see if alignment position is a gap*/
		if((idx=ajInt2dGet(seq_pos, memb_cnt, i))==-1)
		    continue;
		else
		    ajInt2dPut(&keyres_seq, memb_cnt, idx, 1); 
	    }
	}
    }


    /* Allocate signature structure and write SCOP classification records*/
    sig =  ajXyzSignatureNew(sig_npos);
    ajStrAss(&sig->Class, alg->Class);
    ajStrAss(&sig->Fold, alg->Fold);
    ajStrAss(&sig->Superfamily, alg->Superfamily);
    ajStrAss(&sig->Family, alg->Family);
    

    /* Allocate sigdat structures, don't know the number of 
       residue or gaps in advance, these are set below */
    for(x=0; x<sig->npos; x++)
	sig->dat[x]=ajXyzSigdatNew(0, 0);


    /* Write signature structure */
    for(j=0; j<alg->N; j++)
    {
	for(npos=0, gsiz=0, i=0, imax=ajIntGet(seq_len, j); 
	    i<imax; 
	    i++)       
        {
	    /* The position is a signature position */
            if(ajInt2dGet(keyres_seq, j, i) == 1)
	    {
		/*Process gap */
		for(done=ajFalse,x=0;x<sig->dat[npos]->ngap;x++)
		{
		    /*The gap length is NOT new*/
		    if((ajIntGet(sig->dat[npos]->gsiz, x)==gsiz))
		    {
			ajIntInc(&sig->dat[npos]->gfrq, x);
			done=ajTrue;
			break;
		    }	
		}
		

		/*The gap length is new*/
		if(!done)
		{
		    sig->dat[npos]->ngap++;
		    ajIntPut(&sig->dat[npos]->gsiz, sig->dat[npos]->ngap-1, 
			     gsiz);
		    ajIntPut(&sig->dat[npos]->gfrq, sig->dat[npos]->ngap-1, 
			     (ajint) 1);
		}    


		/*Process residue*/
		for(done=ajFalse,x=0;x<sig->dat[npos]->nres;x++)
		    /*The residue id is NOT new*/
		{
		    if((ajChararrGet(sig->dat[npos]->rids, x))
		       ==ajStrChar(seq_array[j], i))
		    {
			ajIntInc(&sig->dat[npos]->rfrq, x);
			done=ajTrue;
			break;
		    }
		}


		/*The residue id is new*/
		if(!done)
		{
		    sig->dat[npos]->nres++;
		    ajChararrPut(&sig->dat[npos]->rids, sig->dat[npos]->nres-1, 
				 ajStrChar(seq_array[j], i));

		    ajIntPut(&sig->dat[npos]->rfrq, sig->dat[npos]->nres-1, 
			     (ajint) 1);
		}    
		

		/* Set variables*/
		gsiz=0;
		npos++;
	    }
	    else
	    {
		gsiz++;
	    }
	}
    }


/* Keep this until ajsort.c has been fixed
    printf("PREORDER\n");
    printf("No.gaps: %d   No.res: %d\n", sig->dat[0]->ngap, 
    sig->dat[0]->nres);
    for(x=0; x<sig->dat[0]->ngap;x++)
	printf("siz:%d frq:%d\n", ajIntGet(sig->dat[0]->gsiz, x), 
	ajIntGet(sig->dat[0]->gfrq, x));
  */  
    
	
    /* Reorder the gap data so it is in order of increasing sized gap*/
    for(x=0; x<sig->npos;x++)
    {
	ajSortIntIncI((ajint *) ajIntInt(sig->dat[x]->gsiz), 
		      (ajint *) ajIntInt(sig->dat[x]->gfrq),  
		      sig->dat[x]->ngap);
	ajSortIntInc((ajint *) ajIntInt(sig->dat[x]->gsiz), sig->dat[x]->ngap);
    }
    

/* Keep this until ajsort.c has been fixed
    printf("POSTORDER\n");
     printf("No.gaps: %d   No.res: %d\n", sig->dat[0]->ngap, 
     sig->dat[0]->nres);
    for(x=0; x<sig->dat[0]->ngap;x++)
	printf("siz:%d frq:%d\n", ajIntGet(sig->dat[0]->gsiz, x), 
	ajIntGet(sig->dat[0]->gfrq, x));
  */  
    
    
    /* JC stuff for printing out in old signature format */
    /*
    for(memb_cnt=0; memb_cnt<alg->N; memb_cnt++)
    {
        printf(">>>TEST_%d\n", memb_cnt); 
        num = 0;
        printf("SEQU      "); 
        for(i=0; i<alg->width; i++)
        {
            if((ajStrChar(alg->Seqs[memb_cnt], i) != '-'))
            {
                ajFmtPrint("%c", ajStrChar(alg->Seqs[memb_cnt], i)); 

                num++;
                ajStrAppK(&seq_array[memb_cnt], 
		ajStrChar(alg->Seqs[memb_cnt], i)); 
            }
        }
        printf("\n");
        printf("KEY       "); 
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)       
        {
            if(ajInt2dGet(keyres_seq, memb_cnt, i) == 1)
                printf("V");
            else
                printf(" ");
        }
        printf("\n");
        printf("SSA4      \n");
        printf("SSA4      \n");
        printf("KEY       ");
        for(i=0; i<ajIntGet(seq_len, memb_cnt); i++)       
        {
            if(ajInt2dGet(keyres_seq, memb_cnt, i) == 1)
                printf("V");
            else
                printf(" ");
        }
        printf("\n");
        printf("SEQU      ");
        for(i=0; i<alg->width; i++)
        {
            if((ajStrChar(alg->Seqs[memb_cnt], i) != '-'))
            {
                ajFmtPrint("%c", ajStrChar(alg->Seqs[memb_cnt], i));
                num++;
                ajStrAppK(&seq_array[memb_cnt], 
		ajStrChar(alg->Seqs[memb_cnt], i));
            }
        }
        printf("\n");
	}
*/	
	




    /* Tidy up */
    ajFloatDel(&seq_normal);
    ajFloatDel(&ncon_normal);
    ajFloatDel(&ccon_normal);
    ajFloatDel(&total_score);
    ajIntDel(&keyres_pos);   
    ajIntDel(&post_sim);     
    ajInt2dDel(&keyres_seq);
    ajIntDel(&seq_len);
    for(x=0;x<nseqs;x++)
	ajStrDel(&seq_array[x]);
    AJFREE(seq_array);
    

    /* Return */
    return sig;
}





/* @func siggen_ScoreAlignment ************************************************
 **
 ** Convenience routine - calls several functions to score an aligment.
 **
 ** @param [r] alg     [AjPScopalg ]    Alignment
 ** @param [w] scores  [AjPScorealg*]   Scores for alignment
 ** @param [r] cmaps   [AjPCmap*]       Residue contacts
 ** @param [r] mat     [AjPMatrixf]     Subsitution matrix
 ** @param [r] seq_pos [AjPInt2d]       Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
AjBool siggen_ScoreAlignment(AjPScorealg *scores, AjPScopalg alg, 
			     AjPCmap *cmaps, AjPMatrixf  mat, AjPInt2d seq_pos)
{
    /*Check args */
    if( !(*scores) || !alg || !(*cmaps) || !mat || !seq_pos)
	return ajFalse;
    

    /* Call scoring functions as appropriate */
    if((*scores)->seq_do)      
	siggen_ScoreSeq(alg, scores, mat, seq_pos);
    

    if((*scores)->ncon_do)     
	siggen_ScoreNcon(alg, scores, cmaps, seq_pos);
    

    if((*scores)->ccon_do)
	siggen_ScoreCcon(alg, scores, cmaps, seq_pos); 
    

    /* siggen_ScoreCombined(scores);*/
    

    return ajTrue;
}





/* @func siggen_CalcSeqpos ****************************************************
 **
 ** Reads a Scopalg object and calculates an index for the alignment.
 **
 ** @param [r] alg     [AjPScopalg]   Alignment
 ** @param [w] seq_pos [AjPInt2d]     Index for alignment
 **
 ** @return [AjBool] True on succcess
 ** @@
 ******************************************************************************/
AjBool siggen_CalcSeqpos(AjPScopalg alg, AjPInt2d *seq_pos)
{
    ajint       z             =0;       /* Loop counter */
    ajint       memb_cnt      =0;       /* Counter for members of the family (alignment) */
    ajint       wid_cnt       =0;       /* Counter for position in the sequence */
    ajint       seq_cnt       =0;       /* Counter for position in seq w.r.t alignment */
    AjIStr      iter          =NULL; /* Iterator for sequence string */




    
    /*Check args */
    if(!alg)
	return ajFalse;


    /* This section determines the position of each aligned residue 
       in its original protein sequence  */
    /* Allocate memory for the seq_pos array  */
    *seq_pos    = ajInt2dNewL((ajint)alg->N);    

    
    /*Set reserved size */
    for(z = 0; z < alg->N; z++)
	ajInt2dPut(seq_pos, z, alg->width, (ajint) 0);


    /* Determine position of each residue in alignment */
    for(memb_cnt = 0; memb_cnt < alg->N; memb_cnt++)
    {
	/* Assign iterator for post_similar line */
	iter = ajStrIter((alg->Seqs[memb_cnt]));
	
	/* Counter of sequence, reset for each member */
	seq_cnt = 0;
	
	
	for(wid_cnt = 0; wid_cnt < alg->width; wid_cnt++)
	{
	    /* Check if sequence line is not '-' */     
	    if(ajStrIterGetK(iter) != '-')
	    {
		/* For every position in alignment assign */
		/* position of residue from its respective sequence */
		ajInt2dPut(seq_pos, memb_cnt, wid_cnt, seq_cnt);
		seq_cnt++;
	    }
	    else
		ajInt2dPut(seq_pos, memb_cnt, wid_cnt, -1);
	    
	    
	    ajStrIterNext(iter);                                   
	}
	ajStrIterFree(&iter);
    }
        

    /* Tidy up and return */
    return ajTrue;
}
