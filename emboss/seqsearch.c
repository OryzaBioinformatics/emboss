/* @source seqsearch application
**
** Generate files of hits for families in a scop classification file by using 
** PSI-BLAST with seed alignments.
**
** @author: Copyright (C) Ranjeeva Ranasinghe (rranasin@hgmp.mrc.ac.uk)
** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
** @@
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
**
** 
** 
******************************************************************************
**IMPORTANT NOTE      IMPORTANT NOTE      IMPORTANT NOTE        IMPORTANT NOTE
******************************************************************************
**
** Mon May 20 11:43:39 BST 2002
**
** The following documentation is out-of-date and should be disregarded.  It 
** will be updated shortly. 
** 
******************************************************************************
**IMPORTANT NOTE      IMPORTANT NOTE      IMPORTANT NOTE        IMPORTANT NOTE
******************************************************************************
** 
**
** 
** 
** 
** Operation 
** 
** seqsearch parses a stamp alignment annotated with SCOP
** classification records, such as those generated by the EMBOSS
** applications scopalign, and using the alignment as a seed, calls
** PSIBLAST to search a sequence database.  It writes a file of hits
** (relatives to proteins of each alignment) in embl-like format.
** 
** PSIBLAST runs on each alignment in a specified directory. The output files 
** are parsed and those hits achieving less than a specified threshold E-value 
** are written to the file of hits. 
** 
** The output file (Figure 1) uses the following records 
** The following four SCOP classification records are taken from the alignment 
** input file: 
** (1)  CL - Domain class.  It is identical to the text given after 'Class' in 
** the scop classification file (see documentation for the EMBOSS application 
** scope). 
** (2)  FO - Domain fold.  It is identical to the text given after 'Fold' in 
** the scop classification file (see scope documentation). 
** (3)  SF - Domain superfamily.  It is identical to the text given after 
** 'Superfamily' in the scop classification file (see scope documentation).
** (4) FA - Domain family. It is identical to the text given after
** 'Family' in the scop classification file (see scope documentation).
** (5) SI - SCOP Sunid's of the family. This number uniquely
** identifies the family in the SCOP parsable files.
** (6)  NS - Number in set. The number of hits for this family. The file will 
** have a section containing an NN, AC, CL, RA and SQ records (see below) for 
** each sequence in the set. 
** (7) NN - Sequence number.  The number given in brackets after this record 
** indicates the start of the data for the relevent sequence. 
** (8) AC - Accession number of the hit. 
** (9) TY - Classification of hit.  Has the value HIT (for sequences retrieved 
** by psi-blast).
** (Files of this type are also generated by the EMBOSS application swissparse 
** and may be be hand edited with additional sequences, in either case, the 
** value OTHER will be given for this record). Files of this type that have
** been processed by
** (10) RA - Sequence range. The numbers before START and END give the
** start and end positions respectively of the hit relative to the
** full length sequence in the swissprot database (a '.' may be given
** for swissparse output files - see swissparse documentation).
** (11) SQ - protein sequence. The number of residues is given before
** AA on the first line. The protein sequence is given on subsequent
** lines.
** (12) XX - used for spacing. 
** (13) // - used to delimit data for each psiblast run (family).
** 
** 
** Figure 1  Excerpt from seqsearch output file 
** 
**  CL   All alpha proteins 
**  XX 
**  FO   Globin-like 
**  XX 
**  SF   Globin-like 
**  XX 
**  FA   Globins 
**  XX
**  SI   14982
**  XX 
**  NS   1 
**  XX 
**  NN   [1] 
**  XX 
**  AC   HBDEX1 
**  XX 
**  TY   HIT
**  XX 
**  RA   2 START; 79 END; 
**  XX 
**  SQ   SEQUENCE   141 AA;  15127 MW;  5EC7DB1E CRC32; 
**       VLSPADKTNV KAAWGKVGAH AGEYGAEALE RMFLSFPTTK TYFPHFDLSH GSAQVKGHGK 
**       KVADALTNAV AHVDDMPNAL SALSDLHAHK LRVDPVNFKL LSHCLLVTLA AHLPAEFTPA 
**       VHASLDKFLA SVSTVLTSKY R 
**  XX 
**  NN   [2] 
**  XX 
**  AC   HBDEX2 
**  XX 
**  TY   HIT
**  XX 
**  RA   2 START; 79 END; 
**  XX 
**  SQ   SEQUENCE   141 AA;  15127 MW;  5EC7DB1E CRC32; 
**       VLSPADKTNV KAAWGKVGAH AGEYGAEALE RMFLSFPTTK TYFPHFDLSH GSAQVKGHGK 
**       KVADALTNAV AHVDDMPNAL SALSDLHAHK LRVDPVNFKL LSHCLLVTLA AHLPAEFTPA 
**       VHASLDKFLA SVSTVLTSKY R 
**  XX 
**  // 
**  CL   All alpha proteins 
**  XX 
**  FO   Globin-like 
**  XX 
**  SF   Globin-like 
**  XX 
**  FA   Phycocyanins 
**  XX 
**  XX
**  SI   14321
** 
** 
** 
**  Notes 
** 
**  Must implement better way of producing value of TRAIN for TY record - 
**  which uses file of correspondence between SCOP domains and SWISPROT 
**  sequences ?   At the moment, if a hit is an exact substring of at 
**  least one of the sequences from the SCOP alignment, then it is taken
**  to be a member of the training set.
**
** 
**  Important Note
**
**  WHEN RUNNING SEQSEARCH AT THE HGMP IT IS ESSENTIAL THAT THE
**  COMMAND 'use blast_v2' (which runs the script
**  /packages/menu/USE/blast_v2) IS GIVEN BEFORE IT IS RUN.  seqsearch
**  is hard-coded to give to scan swissprot, (-d swissprot option to
**  blastpgp. This is probably specific to use on the HGMP
**  server. Option to run seqsearch on any blast-indexed database will
**  be implemented in the future (acd entry and code is below).
**  string: database [ param: Y prompt: "BLAST database to search"
**  def: "./swissprot" ]
**
**  database   = ajAcdGetString("database");
**  

******************************************************************************/ 
        

#include "emboss.h"




static AjPHitlist seqsearch_ajXyzHitlistPsiblast(AjPScopalg scopalg,
						 AjPFile psif);
static AjPFile seqsearch_ajXyzScopalgPsiblast(AjPScopalg scopalg,
					      AjPFile alignf, 
					      AjPStr *psiname, ajint niter, 
					      ajint maxhits, float evalue, 
					      AjPStr database);
static AjPFile seqsearch_ajXyzScopPsiblast(AjPStr singlet, AjPStr *psiname, 
                                           ajint niter, ajint maxhits, 
                                           float evalue,  AjPStr database);
static AjBool ajXyzFindSunId(ajint id, AjPStr *seq, AjPList list);
static ajint ajXyzSunIdBinSearch(ajint id, AjPScop *arr, ajint siz);
static int ajXyzCompSunId(const void *entry1, const void *entry2);



/* @prog seqsearch ************************************************************
**
** Testing
**
******************************************************************************/

int main(int argc, char **argv)
{
    AjPStr     align     = NULL;   /* Location of alignment files for input */
    AjPStr     alignextn = NULL;   /* File extension of alignment files */
    AjPStr     alignname = NULL;   /* Name of alignment file */

    AjPStr     hits      = NULL;   /* Location of hits files for output */
    AjPStr     hitsextn  = NULL;   /* File extension of hits files */
    AjPStr     hitsname  = NULL;   /* Name of hits file */
    AjPStr     singlet   = NULL;   /* sequence of a particular sunid */ 

    AjPStr     database  = NULL;   /* Name of BLAST database to search */ 
    AjPStr     submatrix = NULL;   /* Name of residue substitution matrix */
    AjPStr     msg       = NULL;   /* Error message */
    AjPStr     temp      = NULL;   /* Temp string */
    AjPStr     psiname   = NULL;   /* Name of psiblast output file */

    AjPFile    families  = NULL;   /* Pointer to families file for output */
    AjPFile    logf      = NULL;   /* Log file pointer */
    AjPFile    psif      = NULL;   /* Pointer to psiblast output file*/
    AjPFile    alignf    = NULL;   /* Alignment file pointer */
    AjPFile    Escop     = NULL;   /* File pointer to Escop_seqs.dat */

    ajint      maxhits   = 0;      /* Maximum number of hits reported
                                      by PSIBLAST */
    ajint      niter     = 0;      /* Number of PSIBLAST iterations */
    float      evalue    = 0.0;    /* Threshold E-value for inclusion
                                      in family */

    AjPList    list      = NULL;   /* Used to hold list of names of
                                      files in a directory */
    AjPList    scoplist  = NULL;   /* a list of scop objects */

    AjPScopalg scopalg   = NULL;   /*Scop alignment from input file */
    AjPHitlist hitlist   = NULL;   /* Hitlist object for holding results of 
                                      PSIBLAST hits*/
    
    /* Initialise strings etc */
    alignname = ajStrNew();
    hitsname = ajStrNew();
    msg       = ajStrNew();
    temp      = ajStrNew();
    psiname   = ajStrNew();
    singlet   = ajStrNew();
    
    list     = ajListNew();
    scoplist = ajListNew();

    /* Read data from acd */
    embInit("seqsearch",argc,argv); 
    align      = ajAcdGetString("align");
    alignextn  = ajAcdGetString("alignextn");
    hits       = ajAcdGetString("hits");
    hitsextn   = ajAcdGetString("hitsextn");
    submatrix  = ajAcdGetString("submatrix");
    maxhits    = ajAcdGetInt("maxhits");
    niter      = ajAcdGetInt("niter");
    evalue     = ajAcdGetFloat("evalue");
    logf       = ajAcdGetOutfile("logf");
    Escop      = ajAcdGetInfile("Escop");
    
    
    /* Check directories */
    if(!ajFileDir(&align))
        ajFatal("Could not open alignments directory");
    if(!ajFileDir(&hits))
        ajFatal("Could not open hits directory");
    
    
    /* Create list of files in align directory */
    ajStrAssC(&temp, "*");      
    if((ajStrChar(alignextn, 0)=='.'))
        ajStrApp(&temp, alignextn);    
    else
    {
        ajStrAppC(&temp, ".");    
        ajStrApp(&temp, alignextn);    
    }
    
    ajFileScan(align,temp,&list,ajFalse,ajFalse,NULL,NULL,ajFalse,NULL); 

    /* create a list of scop objects */
    ajXyzScopReadAll(Escop,&scoplist);
    ajFileClose(&Escop);

    /* need to sort the list before binary search otherwise does not work */
    ajListSort(scoplist,ajXyzCompSunId);
    
    /*Start of main application loop*/   
    while(ajListPop(list,(void **)&alignname))
    { 
	ajFmtPrint("PROCESSING %S\n", alignname);
	ajFmtPrintF(logf, "//\n%S\n", alignname);

        /* Open alignment file*/
        if((alignf = ajFileNewIn(alignname)) == NULL)
        {
            ajFmtPrintS(&msg, "Could not open for reading %S", 
                        alignname);
            ajWarn(ajStrStr(msg));
            ajFmtPrintF(logf, "WARN  Could not open for reading %S\n", 
                        alignname);
            continue;       
        }
        
        /* Read alignment file */
        ajXyzScopalgRead(alignf, &scopalg);

        /* seqsearch is hard-coded to give to scan swissprot, (-d
           swissprot option to blastpgp. This is probably specific to
           use on the HGMP server. Option to run seqsearch on any
           blast-indexed database will be implemented in the future */
        ajStrAssC(&database, "swissprot");

        /* check if the file contains a singlet or an alignment */
        if(scopalg->N==0)
        {
	    ajFmtPrintF(logf, "No sequences in alignment (singlet)\n");
            if(!(ajXyzFindSunId(scopalg->Sunid_Family,&singlet,scoplist)))
                ajFatal("The bin search does not work! "
			"email rranasin@hgmp.mrc.ac.uk\n");
            
            /* Generate input files for psiblast from a singlet and
               callpsiblast */
            if(!(psif = seqsearch_ajXyzScopPsiblast(singlet,&psiname,
						    niter,maxhits,
						    evalue,database)))
                ajFatal("Error creating psiblast file"); 
        }

        else
            /* Generate input files from an alignment for psiblast and
               callpsiblast */
            if(!(psif = seqsearch_ajXyzScopalgPsiblast(scopalg,alignf,
						       &psiname,niter,
						       maxhits,evalue,
						       database)))
                ajFatal("Error creating psiblast file");

        /*  Parse the Psi-Blast output file and write a Hitlist object */
        hitlist = seqsearch_ajXyzHitlistPsiblast(scopalg, psif);
        
        /* Close alignment file and delete psiblast output file*/
        ajFileClose(&alignf);
	
	ajFmtPrintS(&temp, "rm %S", psiname);
	system(ajStrStr(temp));

	/*
        ajFmtPrint("***NAME OF PSIBLAST OUTPUT FILE ---> %S", psiname); 
	system(ajStrStr(temp));
        */


        /* Create hits output file name - the name will
           be the same as the Sunid for the SCOP family */
        ajStrAssS(&hitsname, hits);
        ajStrFromInt(&temp, scopalg->Sunid_Family);
        ajStrApp(&hitsname, temp);
        ajStrApp(&hitsname, hitsextn);
        
        if(!(families=ajFileNewOut(hitsname)))
        {
            ajFmtPrintS(&msg, "Could not open for writing %S", 
                        hitsname);
            ajWarn(ajStrStr(msg));
            ajFmtPrintF(logf, "WARN  Could not open for writing %S\n", 
                        hitsname);
            ajXyzHitlistDel(&hitlist);
            ajXyzScopalgDel(&scopalg);  
            ajFileClose(&psif); 

            continue;       
        }       
        
        /* Write the Hitlist object to file */         
        ajXyzHitlistWrite(families, hitlist);
        
        /* Close families file */
        ajFileClose(&families);
        
        /* Free memory etc*/
        ajXyzHitlistDel(&hitlist);
        ajXyzScopalgDel(&scopalg);
        ajFileClose(&psif);     
        ajStrDel(&alignname);
        
    }
    
    /*Tidy up and return */
    ajStrDel(&align);
    ajStrDel(&alignextn);
    ajStrDel(&hits);
    ajStrDel(&hitsextn);
    ajStrDel(&hitsname);
    ajStrDel(&psiname);
    ajStrDel(&database);
    ajStrDel(&submatrix);
    ajStrDel(&msg);
    ajStrDel(&temp);
    ajStrDel(&singlet);
    
    ajFileClose(&logf);
    
    ajListDel(&list);
    ajListDel(&scoplist);
    
    ajExit();
    return 0;
}

/* @funcstatic seqsearch_ajXyzScopalgPsiblast *******************************
**
** Reads a Scopalg object and the corresponding alignment file. Calls psiblast
** to do a search for the SCOP family over a specified database. The psiblast 
** output file is created and a pointer to it provided.
**
** @param [r] scopalg    [AjPScopalg]  Alignment    
** @param [r] alignf     [AjPFile]     Alignment file
** @param [r] psiname    [AjPStr *]    Name of psiblast output file created
** @param [r] niter      [ajint]       No. psiblast iterations
** @param [r] maxhits    [ajint]       Maximum number of hits to generate
** @param [r] evalue     [float]       Threshold E-value for psiblast
** @param [r] database   [AjPStr]      Database name
**
** @return [AjPFile] Pointer to psiblast output file for reading or
** NULL for error.
** @@
** 
** Note
** When the library code function ScopalgWrite is written, we will no longer
** need to pass in a pointer to the alignment file itself. Write ScopalgWrite
** and modify this function accordingly - not urgent.
******************************************************************************/
static AjPFile seqsearch_ajXyzScopalgPsiblast(AjPScopalg scopalg,
					      AjPFile alignf, 
                                              AjPStr *psiname,
					      ajint niter, ajint maxhits, 
                                              float evalue,  AjPStr database)
{
    AjPStr    line      = NULL;         /* Temp string for reading
                                           alignment file */
    AjPStr    name      = NULL;         /* Base name of STAMP temp files */
    AjPStr    temp      = NULL;         /* Temp. string */
    AjPStr    seqin     = NULL;         /* Name of temp. file for
					   PSIBLAST input file (single
					   sequence in FASTA format
					   from alignment */
    AjPStr    seqsin    = NULL;         /* Name of temp. file for
					   PSIBLAST input file
					   (sequences alignment w/o
					   scop records,
					   'Post_similar' or 'Number'
					   lines*/
    AjPStr   *seqs      = NULL;         /* Sequences from alignment */    

    AjPFile   seqsinf   = NULL;         /* File pointer for PSIBLAST
					   input file (multiple sequences)*/
    AjPFile   seqinf    = NULL;         /* File pointer for PSIBLAST
					   input file (single sequence)*/
    AjPFile   psif      = NULL;         /* Pointer to psiblast output file*/
    
    ajint     nseqs     = 0;            /* No. of sequences in alignment */
    ajint     x         = 0;            /* Loop counter */
    

    

    
    /* Rewind alignment file */
    ajFileSeek(alignf,0,SEEK_SET);



    /* Allocate strings */
    line      = ajStrNew();
    name      = ajStrNew();
    temp      = ajStrNew();
    seqin     = ajStrNew();
    seqsin    = ajStrNew();
    


    /* Read scopalg structure and extract sequences only */
    if(!(nseqs=ajXyzScopalgGetseqs(scopalg, &seqs)))
        ajFatal("ajXyzScopalgGetseqs returned 0 sequences in "
                "seqsearch_ajXyzScopalgPsiblast. "
		"Email jison@hgmp.mrc.ac.uk\n");


    /* Initialise random number generator for naming of temp. files
       and create  psiblast input files */
    ajRandomSeed();
    ajStrAssC(&name, ajFileTempName(NULL));
    ajStrAss(&seqsin, name);
    ajStrAppC(&seqsin, ".seqsin");
    ajStrAss(&seqin, name);
    ajStrAppC(&seqin, ".seqin");
    ajStrAss(psiname, name);
    ajStrAppC(psiname, ".psiout");


    seqsinf = ajFileNewOut(seqsin);
    seqinf = ajFileNewOut(seqin);
    

    /* Read alignment file and write psiblast input file
       of multiple sequences */
    while(ajFileReadLine(alignf,&line))
    {
        /* Ignore 'Number', 'Post_similar' and Scop classification lines */
        if((ajStrPrefixC(line,"Number")))
            continue;
        else if (ajStrPrefixC(line,"Post_similar"))
            continue;
        else if(ajStrPrefixC(line,"CL"))
        {
            /*Print blank line at top of output file*/
            ajFmtPrintF(seqsinf,"\n");  
            continue;
        }
        else if(ajStrPrefixC(line,"FO"))
            continue;
        else if(ajStrPrefixC(line,"SF"))
            continue;
        else if(ajStrPrefixC(line,"FA"))
            continue;
        else if(ajStrPrefixC(line,"XX"))
            continue;
        else if(ajStrPrefixC(line,"SI"))
            continue;
        else if(ajStrChar(line,1)=='\0')
        { 
            /* If we are on a blank line
               Print blank line at top of output file*/
            ajFmtPrintF(seqsinf,"\n");  
            continue;
        }
        else
            ajFmtPrintF(seqsinf,"%S\n",line);
    }
    
    

    /* Write psiblast input file of single sequence */    
    ajFmtPrintF(seqinf,">\n%S\n",seqs[0]);
    

    /* Close psiblast input files before psiblast opens them */
    ajFileClose(&seqinf);
    ajFileClose(&seqsinf);

    
    /* Run PSI-BLAST */
    ajFmtPrintS(&temp,
		"blastpgp -i %S -B %S -j %d -e %f -b %d -v %d -d %S > %S\n",
                seqin, seqsin, niter,evalue, maxhits, maxhits,
		database, *psiname);
    ajFmtPrint("%S\n", temp);
    system(ajStrStr(temp));
    
    

    /* Remove temp. files */
    ajFmtPrintS(&temp, "rm %S", seqin);
    system(ajStrStr(temp));
    ajFmtPrintS(&temp, "rm %S", seqsin);
    system(ajStrStr(temp));


    /* Tidy up */
    ajStrDel(&line);
    ajStrDel(&name);
    ajStrDel(&temp);
    ajStrDel(&seqin);   
    ajStrDel(&seqsin);
    for(x=0;x<nseqs;x++)
        ajStrDel(&seqs[x]);     
    AJFREE(seqs);
        

    /* Open psiblast output file and return pointer */
    psif = ajFileNewIn(*psiname);
    return psif;
}

/* @funcstatic seqsearch_ajXyzScopPsiblast ************************************
**
** Calls psiblast to do a search for the SCOP family over a specified 
** database. The psiblast output file is created and a pointer to it provided.
**
** @param [r] singlet    [AjPStr]      Sequence from scop
** @param [r] psiname    [AjPStr *]    Name of psiblast output file created
** @param [r] niter      [ajint]       No. psiblast iterations
** @param [r] maxhits    [ajint]       Maximum number of hits to generate
** @param [r] evalue     [float]       Threshold E-value for psiblast
** @param [r] database   [AjPStr]      Database name
**
** @return [AjPFile] Pointer to psiblast output file for reading or
** NULL for error.
**
** @@
** 
** Note
** When the library code function ScopalgWrite is written, we will no longer
** need to pass in a pointer to the alignment file itself. Write ScopalgWrite
** and modify this function accordingly - not urgent.
*****************************************************************************/
static AjPFile seqsearch_ajXyzScopPsiblast(AjPStr singlet, AjPStr *psiname, 
                                           ajint niter, ajint maxhits, 
                                           float evalue,  AjPStr database)
{
    AjPStr    name      = NULL;         /* Base name of STAMP temp files */
    AjPStr    temp      = NULL;         /* Temp. string */
    AjPStr    seqin     = NULL;         /* Name of temp. file for
					   PSIBLAST input file (single
					   sequence in FASTA format
					   from alignment */

    AjPFile   seqinf    = NULL;         /* File pointer for PSIBLAST
                                           input file (single
                                           sequence)*/
    AjPFile   psif      = NULL;         /* Pointer to psiblast output file*/

    /* Allocate strings */
    name      = ajStrNew();
    temp      = ajStrNew();
    seqin     = ajStrNew();

    /* Initialise random number generator for naming of temp. files
       and create  psiblast input files */
    ajStrAssC(&name, ajFileTempName(NULL));
    ajStrAss(&seqin, name);
    ajStrAppC(&seqin, ".seqin");
    ajStrAss(psiname, name);
    ajStrAppC(psiname, ".psiout");

    /* create output file for psi-blast input file */
    seqinf = ajFileNewOut(seqin);
    
    /* Write psiblast input file of single sequence */    
    ajFmtPrintF(seqinf,">\n%S\n",singlet);
    
    /* Close psiblast input files before psiblast opens them */
    ajFileClose(&seqinf);

    /* Run PSI-BLAST */
    ajFmtPrintS(&temp,"blastpgp -i %S -j %d -e %f -b %d -v %d -d %S > %S\n",
                seqin, niter,evalue, maxhits, maxhits, database, *psiname);
    ajFmtPrint("%S\n", temp);
    system(ajStrStr(temp));

    /* Remove temp. files */
    ajFmtPrintS(&temp, "rm %S", seqin);
    system(ajStrStr(temp));

    /* Tidy up */
    ajStrDel(&name);
    ajStrDel(&temp);
    ajStrDel(&seqin);   

    /* Open psiblast output file and return pointer */
    psif = ajFileNewIn(*psiname);
    return psif;
}


/* @funcstatic seqsearch_ajXyzHitlistPsiblast ********************************
**
** Reads a psiblast output file and writes a Hitlist object containing the 
** hits.
**
** @param [r] scopalg   [AjPScopalg]  Alignment    
** @param [r] psif      [AjPFile]     psiblast output file 
**
** @return [AjPHitlist] Pointer to Hitlist object (or NULL on failure)
** @@
** 
******************************************************************************/
static AjPHitlist seqsearch_ajXyzHitlistPsiblast(AjPScopalg scopalg,
						 AjPFile psif)
{
    /* The hits are organised into blocks, each block contains hits to 
       a protein with a unique accession number.  
       Each hit in a block mnay be spread over multiple lines. nlines 
       is the number of the line (sequence fragment) we are currently on */
    
    
    AjPStr  line       = NULL;  /* Temp string */ 
    AjPStr  acc        = NULL;  /* Acc. number of current hit*/ 
    AjPStr  prevacc    = NULL;  /* Acc. number of previous hit*/ 
    AjPStr  fragseq    = NULL;  /* Sequence fragment */ 
    AjPStr  fullseq    = NULL;  /* Sequence of entire hit */ 

    
    ajint   start      = 0;     /* Start of hit */
    ajint   fragstart  = 0;     /* Start of sequence fragment */
    ajint   fragend    = 0;     /* End of sequence fragment */
    ajint   hitn       = 0;     /* The number of the hit we are on */
    ajint   nhits      = 0;     /* No. of hits in alignment file */
    ajint   fseekr     = 0;

    ajlong  offset     = 0;
    
    AjPHitlist hitlist = NULL;  /* Hitlist object for holding results 
                                   of PSIBLAST hits*/
    
    /* Allocate strings etc */
    line      = ajStrNew();
    acc       = ajStrNew();
    prevacc   = ajStrNew();
    fragseq   = ajStrNew();
    fullseq   = ajStrNew();
    
    /* Calculate the number of hits */
    while(ajFileReadLine(psif,&line))
        if(ajStrFindCaseC(line,"score = ")>=0)
            nhits++;
    fseekr = ajFileSeek(psif,offset,SEEK_SET);
    
    
    /* Allocate memory for Hitlist object */
    if(!(hitlist = ajXyzHitlistNew(nhits)))
        return(hitlist);
    
    
    /* Copy SCOP classification records*/
    /* Assign scop classification records from hitlist structure */
    ajStrAss(&hitlist->Class, scopalg->Class);
    ajStrAss(&hitlist->Fold, scopalg->Fold);
    ajStrAss(&hitlist->Superfamily, scopalg->Superfamily);
    ajStrAss(&hitlist->Family, scopalg->Family);
    hitlist->Sunid_Family = scopalg->Sunid_Family;
    
    /* Loop for whole of input file*/
    while(ajFileReadLine(psif,&line))
    {
        /* We've found a line beginning with > i.e. the start 
           of a block of hits to a single protein*/
        if(ajStrPrefixC(line,">SW:"))
        {
            /* Parse the accession number */
            ajFmtScanS(line, "%*s %S", &prevacc);
        }
        /* We've found a line beginning with ' Score = ' i.e. the
           start of data for a hit */
        else if(ajStrPrefixC(line," Score = "))
        {
            /* Write hit structure, we've parsed  */
            if(hitn!=0)
            {
                hitlist->hits[hitn-1]->Start = start;
                hitlist->hits[hitn-1]->End = fragend;
                ajStrAss(&hitlist->hits[hitn-1]->Acc, acc);
                ajStrAss(&hitlist->hits[hitn-1]->Seq, fullseq);
                ajStrDegap(&hitlist->hits[hitn-1]->Seq);
                ajStrAssC(&hitlist->hits[hitn-1]->Typeobj, "HIT");
                
                /*
                   for(x=0;x<scopalg->N; x++)
                   if((ajStrFindCase(seqs[x], hitlist->hits[hitn-1]->Seq))>=0)
                   {
                   ajStrAssC(&hitlist->hits[hitn-1]->Typeobj, "SEED");
                   break;
                   } 
                   */
            }
            
            /* Reset the sequence of the full hit */
            ajStrAssC(&fullseq, "");

            /* Incremenet hit counter */
            hitn++;

            /* Copy accession number */
            ajStrAss(&acc, prevacc);

        }
        /* Line containing sequence segment of the hit */
        else if(ajStrPrefixC(line,"Sbjct: "))
        {
            /* Parse the start, end and sequence of the fragment */
            ajFmtScanS(line, "%*s %d %S %d", &fragstart, &fragseq, &fragend);

            /* If this is the first fragment, get the start point */
            if(!ajStrCmpC(fullseq, ""))
                start=fragstart;
   
            /* Add fragment to end of sequence of full hit */
            ajStrApp(&fullseq, fragseq);
        }
    }

    /* Write hit structure for last hit */
    if(hitn!=0)
    {
        hitlist->hits[hitn-1]->Start = start;
        hitlist->hits[hitn-1]->End = fragend;
        ajStrAss(&hitlist->hits[hitn-1]->Acc, acc);
        ajStrAss(&hitlist->hits[hitn-1]->Seq, fullseq);
        ajStrDegap(&hitlist->hits[hitn-1]->Seq);
        ajStrAssC(&hitlist->hits[hitn-1]->Typeobj, "HIT");

    }

    /*Tidy up and return */
    ajStrDel(&line);
    ajStrDel(&acc);
    ajStrDel(&prevacc);
    ajStrDel(&fragseq);
    ajStrDel(&fullseq);

    return hitlist;
}

/* @funcstatic ajXyzFindSunId *************************************************
**
** Undocumented
** 
** @param [r] id [ajint] Undocumented
** @param [w] seq  [AjPStr*]  Undocumented
** @param [r] list [AjPList]  Sorted list of objects
**
** @return [AjBool]  True if a swissprot identifier code was found
**                   for the Pdb code.
** @@
******************************************************************************/
static AjBool ajXyzFindSunId(ajint id, AjPStr *seq, AjPList list)
{
    AjPScop *arr = NULL;  /* Array derived from list */
    ajint    dim =0;      /* Size of array */
    ajint    idx =0;      /* Index into array for the Pdb code */

    if(!id || !list)
    {
        ajWarn("Bad args passed to ajXyzFindSunId");
        return ajFalse;
    }
      
    dim = ajListToArray(list, (void ***) &(arr));
    if(!dim)
    {
        ajWarn("Empty list passed to ajXyzFindSunId");
        return ajFalse;
    }

    if((idx = ajXyzSunIdBinSearch(id, arr, dim))==-1)
    {
        AJFREE(arr);
        return ajFalse;
    }
    
    else
    {   
        /* swissprot sequence has priority */
        if((ajStrLen(arr[idx]->SeqSpr))==0)
            ajStrAssS(seq, arr[idx]->SeqPdb);
        else
            ajStrAssS(seq, arr[idx]->SeqSpr);
 
        AJFREE(arr);
        return ajTrue;
    }
}

/* @funcstatic ajXyzSunIdBinSearch ********************************************
**
** Performs a binary search for a scop sunid over an array of Scop
** structures (which of course must first have been sorted). This is a 
** case-insensitive search.
**
** @param [r] id  [ajint]       Search term
** @param [r] arr [AjPScop*]    Array of AjPScop objects
** @param [r] siz [ajint]       Size of array
**
** @return [ajint] Index of first AjPScop object found with an PDB code
** matching id, or -1 if id is not found.
** @@
******************************************************************************/
static ajint ajXyzSunIdBinSearch(ajint id, AjPScop *arr, ajint siz)
{
    int l;
    int m;
    int h;

    l=0;
    h=siz-1;
    while(l<=h)
    {
        m=(l+h)>>1;
        
        if(id < arr[m]->Sunid_Family)
            h=m-1;
        else if(id > arr[m]->Sunid_Family)
            l=m+1;
        else 
            return m;
    }
    return -1;
}

/* @funcstatic ajXyzCompSunId *************************************************
**
** Function to sort AjOScop object by Start Sunid_Family.
**
** @param [r] entry1  [const void*] Pointer to AjOScop object 1
** @param [r] entry2  [const void*] Pointer to AjOScop object 2
**
** @return [int] -1 if Start1 should sort before Start2, +1 if the Start2 
** should sort first. 0 if they are identical.
** @@
******************************************************************************/
static int ajXyzCompSunId(const void *entry1, const void *entry2)
{
    AjPScop p  = NULL;
    AjPScop q  = NULL;

    p = (*(AjPScop*)entry1);
    q = (*(AjPScop*)entry2);
   

    if(p->Sunid_Family < q->Sunid_Family)
        return -1;
    else if(p->Sunid_Family == q->Sunid_Family)
        return 0;
    else
        return 1;
}


