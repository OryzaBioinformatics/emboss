/* @source domainer application
**
** Extract domains from clean PDB files
** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
** @author: Copyright (C) Ranjeeva Ranasinghe (rranasin@hgmp.mrc.ac.uk)
** @author: Copyright (C) Alan Bleasby (ableasby@hgmp.mrc.ac.uk)
** @@
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
******************************************************************************
** 
** 
** 
** 
** 
** 
** Operation
** 
** domainer parses an embl-like format scop classification file generated by 
** the EMBOSS applications scope or nrscope, and clean protein coordinate files
** generated by the coorde application (not currently in emboss, email Jon Ison
** jison@hgmp.mrc.ac.uk) and writes, for each domain in the scop classification 
** file, clean domain coordinate files in embl-like and pdb formats .  Each of
** these files contains coordinates for a single scop domain.  In cases 
** where multiple models were determined, the data in the domain files 
** correspond to the first model.  In the rare cases where a domain is 
** comprised of more than one chain, the data will be presented as belonging 
** to a single chain (i.e. a single sequence, chain identifier etc will be 
** given).
** 
** 
** The pdb format is explained at URL (1)
** (1) http://www.rcsb.org/pdb/docs/format/pdbguide2.2/guide2.2_frame.html
** domainer writes the following records in pdb format:
** (1)  HEADER - bibliographic information.  The text 'CLEANED-UP PDB FILE FOR 
** SCOP DOMAIN XXXXXXX' is always given (where XXXXXXX is a 7-character domain 
** identifier code).
** (2)  TITLE - bibliographic information. The text ' THIS FILE IS MISSING 
** MOST RECORDS FROM THE ORIGINAL PDB FILE' is always given.
** (3)  COMPND - compound information.  The COMPND records from the original  
** pdb file are given.
** (4)  SOURCE - protein source information.  The SOURCE records from the 
** original pdb file are given.
** (5)  REMARK - remark records. Remark records are used for spacing. One 
** REMARK line containing the protein resolution is always given.
** (6)  SEQRES - protein sequence.  
** (7)  ATOM - atomic coordinates.
** (8)  TER - indicates the end of a chain.
** 
**
** The embl-like format used for clean coordinate files uses the following 
** records:
** (1)  ID - Either the 4-character PDB identifier code (for clean protein 
** coordinate files) or the 7-character domain identifier code taken from scop
** (for domain coordinate files; see documentation for the EMBOSS application 
** scope for further info.)
** (2)  DE - compound information.  Text from the COMPND records from the 
** original pdb file are given.
** (3)  OS - protein source information.  Text from the SOURCE records from the 
** original pdb file are given.
** (4)  EX - experimental information. The text 'nmr_or_model' (for nuclear  
** magnetic resonance and model structures) or 'xray' (for structures 
** determined by X-ray crystallography) appears as appropriate after the text
** 'METHOD'.  The resolution of X-ray structures, or '0' for structures of type
** 'nmr_or_model', is given after 'RESO'.  The number of models and number of 
** polypeptide chains are given after 'NMOD' and 'NCHA' respectively. For 
** domain coordinate files a 1 is always given. Following the EX record, the 
** file will have a section containing a CN, IN and SQ records (see below) for
** each chain.
** (5)  CN - chain number.  The number given in brackets after this record 
** indicates the start of a section of chain-specific data.
** (6)  IN - chain specific data. The character given after ID is the PDB chain 
** identifier (a '.' is given in cases where a chain identifier was not 
** specified in the pdb file or, for domain coordinate files, the domain is 
** comprised of more than one domain).  The number of amino acid residues 
** comprising the chain (or the chains from which a domain is comprised) is 
** given after NR. The number of atoms in heterogens and water molecules are 
** given after NH and NW respectively. Domain coordinate files do not include
** coordinates for these groups so a value of 0 is always given.
** (7)  SQ - protein sequence. The number of residues is given before AA on the
** first line. The protein sequence is given on subsequent lines. 
** (8)  CO - coordinate data.  The records are as follows (column numbers are 
** given in parentheses). (1) CO is always given. (2) Model number (always 1 
** for domain coordinate files). (3) Chain number (always 1 for domain 
** coordinate files). (4) Either P (a protein atom), H (a heterogen atom) or W
** (an atom in a water molecule).  (5) Position of the residue in the protein
** sequence given in the SQ record (for protein atoms) or a sequential count
** of the atoms (for heterogens and water). (6) Residue number according to the 
** original pdb file, or or a sequential count of the atoms (for heterogens and 
** water). (7) Single character amino acid code or a '.' (for heterogens and 
** water).  (8) 3-character residue identifier code.  (9) Atom type. (10-12) 
** The x, y and z orthogonal coordinates. (13) Occupancy. (14) Temperature 
** factor.
** (9)  XX - Used for spacing.
** (10) // - Given on the last line of the file only.
** 
** 
** domainer generates a log file an excerpt of which is shown (Figure 1). If 
** there is a problem in processing a domain, three lines containing the 
** record '//', the domain identifier code and an error message respectively
** are written. The text 'WARN  filename not found' is given in cases where a 
** clean coordinate file could not be found. 'ERROR filename file read error' 
** or 'ERROR filename file write error' will be reported when an error was 
** encountered during a file read or write respectively.  Various other error
** messages may also be given (in case of difficulty email Jon Ison, 
** jison@hgmp.mrc.ac.uk).
**
** Figure 1 Excerpt of log file
** //
** DS002__
** WARN  Could not open for reading cpdb file s002.pxyz
** //
** DS003__
** WARN  Could not open for reading cpdb file s003.pxyz
**
******************************************************************************/






#include "emboss.h"






int main(int argc, char **argv)
{
    AjPStr   cpdb_path     =NULL;	/* Path of cpdb files */
    AjPStr   cpdb_extn     =NULL;	/* Extn. of cpdb files */
    AjPStr   pdb_extn      =NULL;	/* Extn. of pdb files */
    AjPStr   pdbscop_path  =NULL;	/* Path of pdbscop files */
    AjPStr   cpdbscop_path =NULL;	/* Path of cpdbscop files */
    AjPStr   cpdb_name     =NULL;	/* Name of cpdb file */
    AjPStr   pdbscop_name  =NULL;	/* Name of pdbscop file */
    AjPStr   cpdbscop_name =NULL;	/* Name of cpdbscop file */
    AjPStr   msg           =NULL;	/* Error message */
    AjPStr   temp          =NULL;	/* Error message */

    AjPFile  scop_inf      =NULL;
    AjPFile  cpdb_inf      =NULL;
    AjPFile  pdbscop_outf  =NULL;
    AjPFile  cpdbscop_outf =NULL;
    AjPFile  errf1         =NULL;
    AjPFile  errf2         =NULL;

    AjPScop  scop=NULL;
    AjPPdb   pdb=NULL;

    
    /* Initialise strings */
    msg           = ajStrNew();
    cpdb_path     = ajStrNew();
    cpdb_extn     = ajStrNew();
    pdb_extn      = ajStrNew();
    pdbscop_path  = ajStrNew();
    cpdbscop_path = ajStrNew();
    cpdb_name     = ajStrNew();
    pdbscop_name  = ajStrNew();
    cpdbscop_name = ajStrNew();
    temp          = ajStrNew();


    /* Read data from acd */
    embInit("domainer",argc,argv); 
    cpdb_path     = ajAcdGetString("cpdb");
    cpdb_extn     = ajAcdGetString("cpdbextn");
    pdb_extn      = ajAcdGetString("pdbextn");
    pdbscop_path  = ajAcdGetString("pdbscop");
    cpdbscop_path = ajAcdGetString("cpdbscop");
    scop_inf      = ajAcdGetInfile("scop");
    errf1         = ajAcdGetOutfile("pdberrf");
    errf2         = ajAcdGetOutfile("cpdberrf");
    

    /* Check directories*/
    if(!ajFileDir(&cpdb_path))
	ajFatal("Could not open cpdb directory");

    if(!ajFileDir(&pdbscop_path))
	ajFatal("Could not open pdbscop directory");

    if(!ajFileDir(&cpdbscop_path))
	ajFatal("Could not open cpdbscop directory");






    /*Start of main application loop*/
    while((ajXyzScopReadC(scop_inf, "*", &scop)))
    {
	/* Write diagnostic */
	ajFmtPrint("%S\n", scop->Entry);   

     
	/* Read clean coordinate file*/
	ajStrAss(&cpdb_name, scop->Pdb);
	ajStrToLower(&cpdb_name);
	ajStrApp(&cpdb_name, cpdb_extn);
	if(!(cpdb_inf=ajFileNewDF(cpdb_path, cpdb_name)))
	{
	    ajFmtPrintS(&msg, "Could not open for reading cpdb file %S", 
			cpdb_name);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(errf1, "//\n%S\nWARN  %S not found\n", 
			scop->Entry, cpdb_name);
	    ajFmtPrintF(errf2, "//\n%S\nWARN  %S not found\n", 
			scop->Entry, cpdb_name);
	    ajFileClose(&cpdb_inf);
	    ajXyzScopDel(&scop);
	    continue;	    
	}
	
	
	/* Write pdb structure */
	if(!ajXyzCpdbRead(cpdb_inf, &pdb))	       
	{
	    ajFmtPrintS(&msg, "Error reading cpdb file %S", cpdb_name);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(errf1, "//\n%S\nERROR %S file read error\n", 
			scop->Entry, cpdb_name);
	    ajFmtPrintF(errf2, "//\n%S\nERROR %S file read error\n", 
			scop->Entry, cpdb_name);
	    ajFileClose(&cpdb_inf);
	    ajXyzScopDel(&scop);
	    ajXyzPdbDel(&pdb);
	    continue;
	}
	

	/* Open pdb format file for writing*/
	ajStrAss(&pdbscop_name, pdbscop_path);
	ajStrApp(&pdbscop_name, scop->Entry);
	ajStrToLower(&pdbscop_name);
	ajStrAppC(&pdbscop_name, ajStrStr(pdb_extn));
	if(!(pdbscop_outf=ajFileNewOut(pdbscop_name)))
	{
	    ajFmtPrintS(&msg, "Could not open for writing pdbscop file %S", 
			pdbscop_name);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(errf1, "//\n%S\nERROR %S file write error\n", 
			scop->Entry, pdbscop_name);
	    ajFileClose(&cpdb_inf);
	    ajFileClose(&pdbscop_outf);
	    ajXyzScopDel(&scop);
	    ajXyzPdbDel(&pdb);
	    continue;
	}   	


	/* Open embl-like format file for writing*/
	ajStrAss(&cpdbscop_name, cpdbscop_path);
	ajStrApp(&cpdbscop_name, scop->Entry);
	ajStrToLower(&cpdbscop_name);
	ajStrApp(&cpdbscop_name, cpdb_extn);
	if(!(cpdbscop_outf=ajFileNewOut(cpdbscop_name)))
	{
	    ajFmtPrintS(&msg, "Could not open for writing cpdbscop file %S", 
			cpdbscop_name);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(errf2, "//\n%S\nERROR %S file write error\n", 
			scop->Entry, cpdbscop_name);
	    ajFileClose(&cpdb_inf);
	    ajFileClose(&cpdbscop_outf);
	    ajXyzScopDel(&scop);
	    ajXyzPdbDel(&pdb);
	    continue;
	}   	
	
	
	/* Write domain coordinate file in pdb format */
	if(!ajXyzPdbWriteDomain(errf1, pdbscop_outf, pdb, scop))
	{
	    ajFmtPrintS(&msg, "Error writing pdbscop file %S", pdbscop_name);
	    ajWarn(ajStrStr(msg));

	    ajFileClose(&pdbscop_outf);
	    ajFmtPrintS(&temp, "rm %S", pdbscop_name);
	    ajFmtPrint("%S", temp);
	    ajSystem(&temp);

	}


	/* Write domain coordinate file in embl-like format */
	if(!ajXyzCpdbWriteDomain(errf2, cpdbscop_outf, pdb, scop))
	{
	    ajFmtPrintS(&msg, "Error writing cpdbscop file %S", 
			cpdbscop_name);
	    ajWarn(ajStrStr(msg));

	    ajFileClose(&cpdbscop_outf);
	    ajFmtPrintS(&temp, "rm %S", cpdbscop_name);
	    ajFmtPrint("%S", temp);
	    
	    ajSystem(&temp);
	}


	/* Tidy up*/
	ajFileClose(&cpdb_inf);
	ajFileClose(&pdbscop_outf);
	ajFileClose(&cpdbscop_outf);
	ajXyzScopDel(&scop);
	ajXyzPdbDel(&pdb);
    }
    /*End of main application loop*/    
    




    /*Tidy up */
    ajStrDel(&cpdb_path);
    ajStrDel(&cpdb_extn);
    ajStrDel(&pdb_extn);
    ajStrDel(&pdbscop_path);
    ajStrDel(&cpdbscop_path);
    ajStrDel(&cpdb_name);
    ajStrDel(&pdbscop_name);
    ajStrDel(&cpdbscop_name);
    ajStrDel(&msg);
    ajStrDel(&temp);
    ajFileClose(&scop_inf);
    ajFileClose(&errf1);
    ajFileClose(&errf2);


    /* Bye Bye */
    ajExit();
    return 0;
}	
