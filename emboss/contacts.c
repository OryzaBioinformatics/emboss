/* @source contacts application
**
** Calculate residue contacts from clean coordinate files
** @author: Copyright (C) Jon Ison (jison@hgmp.mrc.ac.uk)
** @author: Copyright (C) Alan Bleasby (ableasby@hgmp.mrc.ac.uk)
** @@
**
** This program is free software; you can redistribute it and/or
** modify it under the terms of the GNU General Public License
** as published by the Free Software Foundation; either version 2
** of the License, or (at your option) any later version.
** 
** This program is distributed in the hope that it will be useful,
** but WITHOUT ANY WARRANTY; without even the implied warranty of
** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
** GNU General Public License for more details.
** 
** You should have received a copy of the GNU General Public License
** along with this program; if not, write to the Free Software
** Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
******************************************************************************
** 
** 
** 
** 
** 
** 
** Operation
** 
** contacts parses an embl-like clean coordinate files generated by the coorde 
** application (not currently in emboss, email Jon Ison jison@hgmp.mrc.ac.uk) 
** or the domainer application and writes, for each file in a given directory, 
** files of residue-residue contact data in embl-like format.  Each of these 
** files contains residue contact data for each chain of every model in the 
** coordinate file (or the single scop domain in the case where domainer output
** is read).  
**
** Contact between two residues is defined as when the van der Waals surface of 
** any atom of the first residue comes within the threshold contact distance of 
** the van der Waals surface of any atom of the second residue. The threshold 
** contact distance is a user-defined distance with a default value of 1 
** Angstrom.
** 
** The following van der Waals radii are used: 
** C:1.8 Angstrom 
** O:1.4 Angstrom 
** N:1.7 Angstrom 
** S:2.0 Angstrom
** H:1.0 Angstrom (default for other or unknown atom types)
**
** The embl-like format used for the contact files (Figure 1) uses the following 
** records:
** (1)  ID - either the 4-character PDB identifier code (where clean protein 
** coordinate files are used as input) or the 7-character domain identifier 
** code taken from scop (where domain coordinate files were used as input; see 
** documentation for the EMBOSS application scope for further info.)
** (2)  DE - bibliographic information.  The text "Residue-residue contact 
** data" is always given.
** (4)  EX - experimental information. The value of the threshold contact 
** distance is given as a floating point number after 'THRESH'. The number of 
** models and number of polypeptide chains are given after 'NMOD' and 'NCHA' 
** respectively. domain coordinate files a 1 is always given. Following the EX 
** record, the file will have a section containing a CN, IN and SM records 
** (see below) for each chain. The sections for each chain of a model are given 
** after the MO record.
** (5) MO - model number. The number given in brackets after this record 
** indicates the start of a section of model-specific data. 
** (6) CN - chain number.  The number given in brackets after this record 
** indicates the start of a section of chain-specific data.
** (7) IN - chain specific data. The character given after ID is the PDB chain 
** identifier taken from the input file, (a '.` given in cases where a chain 
** identifier was not specified in the original pdb file or, for domain 
** coordinate files, the domain is comprised of more than one domain).  The 
** number of amino acid residues comprising the chain (or the chains from 
** which a domain is comprised) is given after NR. The number of residue-residue
** contacts is given after NSMCON. 
** (8) SM - Line of residue contact data. Pairs of amino acid identifiers and 
** residue numbers are delimited by a ';'. Residue numbers are taken from the 
** clean coordinate file and give a correct index into the sequence (i.e. they
** are not necessarily the same as the original pdb file).
** (9) XX - used for spacing.
** (10) // - given on the last line of the file only.
** 
** Note - SM records are used for contacts between either either side-chain 
** or main-chain atoms as defined above.  In a future implementation, SS will
** be used for side-chain only contacts, MM will be used for main-chain only 
** contacts, and there will probably be several other forms of contact too.
** 
** domainer generates a log file an excerpt of which is shown (Figure 2). If 
** there is a problem in processing a coordinate file, three lines containing 
** the record '//', the scop domain or pdb identifier code and an error message 
** respectively are written. The text 'WARN  file open error filename',
** 'ERROR file read error filename' or 'ERROR file write error filename ' will 
** be reported when an error was encountered during a file open, read or write 
** respectively.  Various other error messages may also be given (in case of 
** difficulty email Jon Ison, jison@hgmp.mrc.ac.uk).
**
** Figure 1 Excerpt from contacts output file
**  ID   D1HBBB_
**  XX
**  DE   Residue-residue side-chain contact data
**  XX
**  EX   THRESH 10.0; NMOD 1; NCHA 1;
**  XX
**  MO   [1]
**  XX
**  CN   [1]
**  XX
**  IN   ID B; NR 146; NSMCON 2514;
**  XX
**  SM   VAL 1 ; HIS 2
**  SM   VAL 1 ; LEU 3
**  SM   VAL 1 ; THR 4
**  SM   VAL 1 ; PRO 5
**  SM   VAL 1 ; GLU 6
**  SM   VAL 1 ; GLU 7
**  SM   VAL 1 ; LYS 8
**  SM   VAL 1 ; VAL 11
**  SM   VAL 1 ; PHE 71
**
** Figure 2 Excerpt of log file
** //
** DS002__
** WARN  Could not open for reading cpdb file s002.pxyz
** //
** DS003__
** WARN  Could not open for reading cpdb file s003.pxyz
**
** Notes
**
******************************************************************************/






#include "emboss.h"
#include "math.h"

AjBool	ajXyzContactsWrite(AjPFile logf, AjPFile outf, float thresh, 
			   AjPPdb pdb, AjPVdwall vdw);
AjBool	ajXyzPrintContactMap(AjPFile outf, AjPInt2d mat, char *txt, 
			     ajint mod, ajint chn, AjPPdb pdb);
AjBool	ajXyzWriteContactMap(AjPInt2d *mat, ajint *ncon, ajint dim, 
			     float thresh, ajint mod, ajint chn, AjPPdb pdb, 
			     AjPVdwall vdw);
AjBool  ajXyzInContact(AjPAtom atm1, AjPAtom atm2, float thresh, 
		       AjPVdwall vdw);









int main(ajint argc, char **argv)
{
    AjPStr     cpdb_path     =NULL;	/* Path of cpdb files */
    AjPStr     cpdb_extn     =NULL;	/* Extn. of cpdb files */
    AjPStr     cpdb_name     =NULL;	/* Name of cpdb file */
    AjPStr     con_path      =NULL;	/* Path of contact files */
    AjPStr     con_extn      =NULL;	/* Extn. of contact files */
    AjPStr     con_name      =NULL;	/* Name of contact file */
    AjPStr     msg           =NULL;	/* Error message */
    AjPStr     temp          =NULL;	/* Temp string */

    AjPFile    cpdb_inf      =NULL;     /* cpdb input file pointer */
    AjPFile    con_outf      =NULL;     /* contact output file pointer */
    AjPFile    logf          =NULL;     /* log file pointer*/
    AjPFile    vdwf          =NULL;     /* van der Waals file pointer*/

    AjPPdb     pdb           =NULL;

    AjPList    list          =NULL;       

    float      thresh        =0;
    
    AjPVdwall  vdw           =NULL;     /* Structure for vdw radii */
    



    
    /* Initialise strings */
    temp          = ajStrNew();
    msg           = ajStrNew();
    cpdb_path     = ajStrNew();
    cpdb_extn     = ajStrNew();
    cpdb_name     = ajStrNew();
    con_path      = ajStrNew();
    con_extn      = ajStrNew();
    con_name      = ajStrNew();


    /* Read data from acd */
    embInit("contacts",argc,argv); 
    cpdb_path     = ajAcdGetString("cpdb");
    cpdb_extn     = ajAcdGetString("cpdbextn");
    con_path      = ajAcdGetString("con");
    con_extn      = ajAcdGetString("conextn");
    logf          = ajAcdGetOutfile("conerrf");
    thresh        = ajAcdGetFloat("thresh");
    vdwf          = ajAcdGetInfile("vdwf");


    /* Check directories*/
    if(!ajFileDir(&cpdb_path))
	ajFatal("Could not open cpdb directory");

    if(!ajFileDir(&con_path))
	ajFatal("Could not open contact directory");


    /* Create list of files in cpdb directory */
    list = ajListNew();
    ajStrAssC(&temp, "*");	
    if((ajStrChar(cpdb_extn, 0)=='.'))
	ajStrApp(&temp, cpdb_extn);    
    else
    {
	ajStrAppC(&temp, ".");    
	ajStrApp(&temp, cpdb_extn);    
    }
    ajFileScan(cpdb_path, temp, &list, ajFalse, ajFalse, NULL, NULL, 
	       ajFalse, NULL); 


    /* Allocate and read Vdwall object */
    if(!ajXyzVdwallRead(vdwf, &vdw))
	ajFatal("Error reading vdw radii file\n");





    /*Start of main application loop*/
    while(ajListPop(list,(void **)&temp))
    {
	/* Read clean coordinate file*/
	if((cpdb_inf=ajFileNewIn(temp))==NULL)
	{
	    ajFmtPrintS(&msg, "Could not open for reading %S %S", 
			temp);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(logf, "WARN  Could not open for reading %S\n", 
			temp);
	    ajFileClose(&cpdb_inf);
	    ajStrDel(&temp);	
	    continue;	    
	}


	/* Read pdb structure */
	if(!ajXyzCpdbRead(cpdb_inf, &pdb))	       
	{
	    ajFmtPrintS(&msg, "ERROR file read error %S", temp);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(logf, "ERROR  file read error %S\n", temp);
	    ajFileClose(&cpdb_inf);
	    ajXyzPdbDel(&pdb);
	    ajStrDel(&temp);	
	    continue;
	}


	/* Open contact file for writing*/
	ajStrAss(&con_name, con_path);
	ajStrApp(&con_name, pdb->Pdb);
	ajStrToLower(&con_name);
	ajStrAppC(&con_name, ajStrStr(con_extn));
	if(!(con_outf=ajFileNewOut(con_name)))
	{
	    ajFmtPrintS(&msg, "ERROR file open error %S", 
			con_name);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(logf, "ERROR file open error %S\n", con_name);
	    ajFileClose(&cpdb_inf);
	    ajFileClose(&con_outf);
	    ajXyzPdbDel(&pdb);
	    ajStrDel(&temp);	
	    continue;
	}  
    
	
	/* Write contacts file */
	if(!ajXyzContactsWrite(logf, con_outf, thresh, pdb, vdw))
	{
	    ajFmtPrintS(&msg, "ERROR  file write error %S", con_name);
	    ajWarn(ajStrStr(msg));
	    ajFmtPrintF(logf, "ERROR  file write error %S\n", con_name);

	    ajFmtPrintS(&temp, "rm %S", con_name);
	    ajFmtPrint("%S", temp);
	    ajSystem(&temp);

	    ajFileClose(&cpdb_inf);
	    ajFileClose(&con_outf);
	    ajXyzPdbDel(&pdb);
	    ajStrDel(&temp);	
	    continue;
	}


	/* Write diagnostic */
	ajFmtPrint("%S\n", pdb->Pdb);   
	ajFmtPrintF(logf, "%S\n", pdb->Pdb);   
	

	/* Tidy up*/
	ajFileClose(&cpdb_inf);
	ajFileClose(&con_outf);
	ajXyzPdbDel(&pdb);
	ajStrDel(&temp);	
    }
    /*End of main application loop*/    





    /*Tidy up */
    ajStrDel(&cpdb_path);
    ajStrDel(&cpdb_extn);
    ajStrDel(&cpdb_name);
    ajStrDel(&con_path);
    ajStrDel(&con_extn);
    ajStrDel(&con_name);
    ajStrDel(&msg);
    ajStrDel(&temp);

    ajFileClose(&cpdb_inf);
    ajFileClose(&con_outf);
    ajFileClose(&logf);
    ajFileClose(&vdwf);

    ajListDel(&list);
    ajXyzVdwallDel(&vdw);
    

    /* Return */
    ajExit();
    return 0;
}	





/* @func ajXyzContactsWrite **************************************************
**
** Writes a file of residue contact data in embl-like format for a pdb 
** structure.
**
** @param [w] logf   [AjPFile] Output file stream (log file)
** @param [w] outf   [AjPFile] Output file stream (contact file)
** @param [r] thresh [float]   Threshold contact distance
** @param [r] pdb    [AjPPdb]  Pdb object
** @param [r] vdw    [AjPVdwall]   Vdwall object
**
** @return [AjBool] True on success
** @@
**
******************************************************************************/

AjBool	ajXyzContactsWrite(AjPFile logf, AjPFile outf, float thresh, 
			   AjPPdb pdb, AjPVdwall vdw)
{
    AjPInt2d    mat   =NULL;    /* Contact map */
    ajint       x,y,z;          /* Loop counters */
    ajint       ncon  =0;       /* No. contacts (1's) in matrix */
    




    /* Error checking on args */
    if(!logf || !outf || !pdb)
	return ajFalse;
    
    
    /* Print out header data */
    ajFmtPrintF(outf, "%-5s%S\n", "ID", pdb->Pdb);
    ajFmtPrintF(outf, "XX\n");
    ajFmtPrintF(outf, "%-5s%s\n", 
		"DE", "Residue-residue side-chain contact data");
    ajFmtPrintF(outf, "XX\n");
    ajFmtPrintF(outf, "%-5s%s%.1f; NMOD %d; NCHA %d;\n", "EX", "THRESH ", 
		thresh, pdb->Nmod, pdb->Nchn);


    /* Start of loop to print out data for each model / chain */
    for(x=0;x<pdb->Nmod;x++)
    {
	/* Print out model-specific data */
	ajFmtPrintF(outf, "XX\n%-5s[%d]\n", "MO", x+1);	
	ajFmtPrintF(outf, "XX\n");	


	for(y=0;y<pdb->Nchn;y++)
	{
	    /* Allocate memory for the contact map (a SQUARE 2d int array) */
	    mat = ajInt2dNewL((ajint)pdb->Chains[y]->Nres);   	
	    for(z=0;z<pdb->Chains[y]->Nres;++z)
		ajInt2dPut(&mat, z, pdb->Chains[y]->Nres-1, (ajint) 0);

	    
	    /* Write the contact map */
	    if(!ajXyzWriteContactMap(&mat, &ncon, pdb->Chains[y]->Nres, 
				     thresh, x+1, y+1, pdb,  vdw))
	    {
		ajFmtPrintF(logf, "ERROR  Writing contact map\n");
		ajInt2dDel(&mat);
		return ajFalse;
	    }


	    /* Print out chain-specific data */
	    ajFmtPrintF(outf, "%-5s[%d]\n", "CN", y+1);	
	    ajFmtPrintF(outf, "XX\n");	
	    ajFmtPrintF(outf, "%-5sID %c; NR %d; NSMCON %d;\n", 
			"IN", 
 			pdb->Chains[y]->Id,
			pdb->Chains[y]->Nres,
			ncon);
	    ajFmtPrintF(outf, "XX\n");	


	    if(ncon)
	    {
		/*Matrix written OK and has at least 1 contact*/
		ajXyzPrintContactMap(outf, mat, "SM", x+1, y+1, pdb);   
		ajFmtPrintF(outf, "XX\n");	
	    }
	    else 
	    {
		/* Empty matrix ! */
		ajFmtPrintF(outf, ".\nXX\n");	
	    }


	    /* Free memory for matrix */
	    ajInt2dDel(&mat);
	}
    }
    /* End of loop to print out data for each model / chain */
    ajFmtPrintF(outf, "//\n");    





    /* Return */
    return ajTrue;
}





/* @func ajXyzPrintContactMap ************************************************
**
** Writes data in a contact map to file for a certain model and chain in a pdb 
** structure.
**
** @param [w] outf [AjPFile]     Output file stream (contact file)
** @param [r] mat  [AjPInt2d]    Contact map
** @param [r] txt  [char*]        Text to print at start of each line
** @param [r] mod  [ajint]         Model number
** @param [r] chn  [ajint]         Chain number
** @param [r] pdb  [AjPPdb]      Pdb object
** 
** It writes a line to the output file for each contact. In the example below, 
** txt has a value of "SM":
** 
** SM   His 2 ; Val 8
** SM   Ala 6 ; Trp 21
** 
** @return [AjBool] True if file was succesfully written.
** @@
**
****************************************************************************/
AjBool	ajXyzPrintContactMap(AjPFile outf, AjPInt2d mat, char *txt, ajint mod, 
			     ajint chn, AjPPdb pdb)
{
    ajint      x,y;           /* Loop counters */    
    AjPStr   res1;          /* ID of residue 1 */
    AjPStr   res2;          /* ID of residue 2 */


    /* Error checking on args */
    if(!outf || !mat || !pdb || !txt)
	{
	    ajWarn("Null arg. passed to ajXyzPrintContactMap");		
	    return ajFalse;
	}
    

    /* Allocate strings */
    res1 = ajStrNew();
    res2 = ajStrNew();


    /* Start of loop for printing out contacts */
    for(x=0; x<pdb->Chains[chn-1]->Nres; x++)
	for(y=x+1; y<pdb->Chains[chn-1]->Nres; y++)
	{
	    if((ajInt2dGet(mat, x, y)==1))
	    {
		/* Assign residue id */
		    if(!ajBaseAa1ToAa3(ajStrChar(pdb->Chains[chn-1]->Seq, x), 
				       &res1))
		    {
			ajStrDel(&res1);
			ajStrDel(&res2);  
			ajWarn("Index out of range in ajXyzPrintPdbSeqresChain");		
			return ajFalse;
		    }
		    if(!ajBaseAa1ToAa3(ajStrChar(pdb->Chains[chn-1]->Seq, y), 
				       &res2))
		    {
			ajStrDel(&res1);
			ajStrDel(&res2);  
			ajWarn("Index out of range in ajXyzPrintPdbSeqresChain");		
			return ajFalse;
		    }
 		/* Print out the contact */
		ajFmtPrintF(outf, "%-5s%S %d ; %S %d\n", txt, res1, x+1, 
			    res2, y+1);	
	    }
	}

    
    /*Tidy up */
    ajStrDel(&res1);
    ajStrDel(&res2);  


    /* Return */
    return ajTrue;
}	





/* @func ajXyzWriteContactMap ************************************************
**
** Writes a residue contact map for a specified model and chain in a pdb 
** structure.  
**
** @param [w] mat    [AjPInt2d *]  Contact map
** @param [w] ncon   [ajint *]     No. contacts (1's) in contact map
** @param [w] dim    [ajint]       Dimension of the contact map 
** @param [r] thresh [float]       Threshold contact distance
** @param [r] mod    [ajint]       Model number
** @param [r] chn    [ajint]       Chain number
** @param [r] pdb    [AjPPdb]      Pdb object
** @param [r] vdw    [AjPVdwall]   Vdwall object
**
** Contact between two residues is defined as when the van der Waals surface of 
** any atom of the first residue comes within the threshold contact distance
** (thresh) of the van der Waals surface of any atom of the second residue. 
**
** @return [AjBool] True if mat was succesfully written.
** @@
**
*****************************************************************************/
AjBool	ajXyzWriteContactMap(AjPInt2d *mat, ajint *ncon, ajint dim, 
			     float thresh, ajint mod, ajint chn, AjPPdb pdb, 
			     AjPVdwall vdw)
{
    AjPAtom    *arr     =NULL;         /* Array of AjPAtom from pdb list */
    ajint       siz     =0;            /* Size of array */
    ajint       x       =0;            /* Loop counters */
    ajint       y       =0;            /* Loop counters */
    ajint       last_atm=0;
    AjBool      done    =ajFalse;       /* Flag */
    

    /* Error checking on args */
    if(!mat || !pdb || !chn || !mod)
    {	
	ajWarn("Null or zero arg. passed to ajXyzWriteContactMap");		
	return ajFalse;
    }
    

    

    /* Initialise no. contacts to zero */
    (*ncon)=0;
    

    /*Convert the AjPList of atoms to an array of AjPAtom*/
    if(!(siz=ajListToArray((AjPList)pdb->Chains[chn-1]->Atoms,
			   (void ***)&arr)))
    {
	ajWarn("Zero sized list of sequences passed into "
	       "ajXyzWriteContactMap");
	return ajFalse;
    }
    


        
    /* Advance atom 1 counter to the correct model */
    for(x=0; x<siz; x++) 
	/* Find the correct model */
	if(arr[x]->Mod==mod)
	{
	    done=1;
	    break;
	}
    if(!done)
    {
	ajWarn("Model not found in ajXyzWriteContactMap");
	AJFREE(arr);
	return ajFalse;
    } 


    /* Find index postition for last atom */
    for(last_atm=x; last_atm<siz; last_atm++)
	if(arr[last_atm]->Mod!=mod  || arr[last_atm]->Type!='P')
	{
	    last_atm--;
	    break;	
	}
    if(last_atm==siz)
	last_atm--;
    if(last_atm == x)
    {
	ajWarn("No atoms for the chain in ajXyzWriteContactMap");
	AJFREE(arr);
	return ajFalse;
    } 


    
    /* Atom 1 counter - Iterate through the list of atoms */
    for(; x<last_atm+1; x++)
    {
	/* Atom 2 counter - Iterate through the list of atoms */
	for(y=x; y<last_atm+1; y++)
	{
	    /* Jump to next residue if necessary */
	    if(arr[y]->Idx <= arr[x]->Idx)
		continue;


	    /* Check we do not already have a contact for this pair of 
	       residues.
	       First check to see whether index is in range (it should be!)*/
	    if((arr[x]->Idx-1 < dim) && (arr[y]->Idx-1 < dim))
	    {
		if((ajInt2dGet(*mat, arr[x]->Idx-1, arr[y]->Idx-1)==1))
		    continue;   
	    }
	    else
	    {
		/* The residue number should never exceed dim (no. residues 
		   in the chain) */
		ajFatal("Unexpected fatal error.  email culprit "
			"(jison@hgmp.mrc.ac.uk)");
	    }
	    
	    
	    /* Determines whether the two atoms make contact */
	    if(ajXyzInContact(arr[x], arr[y], thresh, vdw))
	    {
		if((ajInt2dGet(*mat, arr[x]->Idx-1, arr[y]->Idx-1)==0))
		{
		    /* Increment no. contacts and write contact map */
		    (*ncon)++;
		    ajInt2dPut(mat, arr[x]->Idx-1, arr[y]->Idx-1, (ajint) 1);
		    ajInt2dPut(mat, arr[y]->Idx-1, arr[x]->Idx-1, (ajint) 1); 
		}
	    }
	}
    }


    /* Tidy up */
    AJFREE(arr);
    

    /* Return */
    return ajTrue;
}









/* @func ajXyzInContact *****************************************************
**
** Determines whether two atoms are in physical contact  
**
** @param [r] atm1   [AjPAtom]     Atom 1 object
** @param [r] atm2   [AjPAtom]     Atom 1 object
** @param [r] thresh [float]       Threshold contact distance
** @param [r] vdw    [AjPVdwall]   Vdwall object
**
** Contact between two atoms is defined as when the van der Waals surface of 
** the first atom comes within the threshold contact distance (thresh) of the 
** van der Waals surface of the second atom.
**
** @return [AjBool] True if the two atoms form contact
** @@
**
******************************************************************************/
AjBool  ajXyzInContact(AjPAtom atm1, AjPAtom atm2, float thresh, AjPVdwall vdw)
{
    float val=0;

    



    val=((atm1->X -  atm2->X) * (atm1->X -  atm2->X)) +
	((atm1->Y -  atm2->Y) * (atm1->Y -  atm2->Y)) +
	    ((atm1->Z -  atm2->Z) * (atm1->Z -  atm2->Z));


    
    if((sqrt(val) - ajXyzVdwRad(atm1, vdw) - ajXyzVdwRad(atm2, vdw)) <= thresh)
	return ajTrue;
    else
	return ajFalse;
} 



/* @func ajXyzVdwRad *****************************************************
**
** Returns the van der Waals radius of an atom. Returns 1.2 as default.
**
** @param [r] atm    [AjPAtom]     Atom object
** @param [r] vdw    [AjPVdwall]   Vdwall object
**
** Contact between two atoms is defined as when the van der Waals surface of 
** the first atom comes within the threshold contact distance (thresh) of the 
** van der Waals surface of the second atom.
**
** @return [float] van der Waals radius of the atom
** @@
**
******************************************************************************/
float ajXyzVdwRad(AjPAtom atm, AjPVdwall vdw)
{
    ajint x=0;
    ajint y=0;
    




    for(x=0;x<vdw->N;x++)
    {
	for(y=0;y<vdw->Res[x]->N;y++)
	{
	    if(ajStrMatch(atm->Atm, vdw->Res[x]->Atm[y]))
		return(vdw->Res[x]->Rad[y]);	 
	}
    }

    
    /* Return default value */
    return((float)1.2);
}
