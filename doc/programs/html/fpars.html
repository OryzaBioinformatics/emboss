<!--START OF HEADER - DON'T ALTER -->

<HTML>
<HEAD>
  <TITLE>
  EMBOSS: fpars
  </TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" text="#000000">



<table align=center border=0 cellspacing=0 cellpadding=0>
<tr><td valign=top>
<A HREF="/" ONMOUSEOVER="self.status='Go to the EMBOSS home page';return true"><img border=0 src="emboss_icon.jpg" alt="" width=150 height=48></a>
</td>
<td align=left valign=middle>
<b><font size="+6">

fpars
</font></b>
</td></tr>
</table>
<br>&nbsp;
<p>



<!--END OF HEADER-->






<H2>
    Function
</H2>
Discrete character parsimony

<!--
DON'T WRITE ANYTHING HERE.
IT IS DONE FOR YOU.
-->




<H2>
    Description
</H2>

Multistate discrete-characters parsimony method. Up to 8 states (as
well as "?") are allowed. Cannot do Camin-Sokal or Dollo
Parsimony. Can cope with multifurcations, reconstruct ancestral
states, use character weights, and infer branch lengths.

<H2>
    Algorithm
</H2>

PARS is a general parsimony program which carries out the Wagner
parsimony method with multiple states. Wagner parsimony allows changes
among all states. The criterion is to find the tree which requires the
minimum number of changes. The Wagner method was originated by Eck and
Dayhoff (1966) and by Kluge and Farris (1969). Here are its
assumptions:


<ol>

<li>
Ancestral states are unknown unknown. 

<li>
Different characters evolve independently. 

<li>
Different lineages evolve independently. 

<li>
Changes to all other states are equally probable (Wagner). 

<li>
These changes are a priori improbable over the evolutionary time spans
involved in the differentiation of the group in question.

<li>
Other kinds of evolutionary event such as retention of polymorphism
are far less probable than these state changes.

<li>
Rates of evolution in different lineages are sufficiently low that two
changes in a long segment of the tree are far less probable than one
change in a short segment.

</ol>

<p>
That these are the assumptions of parsimony methods has been
documented in a series of papers of mine: (1973a, 1978b, 1979, 1981b,
1983b, 1988b). For an opposing view arguing that the parsimony methods
make no substantive assumptions such as these, see the papers by
Farris (1983) and Sober (1983a, 1983b), but also read the exchange
between Felsenstein and Sober (1986).



<H2>
    Usage
</H2>

<!--  
	Example usage, as run from the command-line.
        Many examples illustrating different behaviours is good.
 -->

<b>Here is a sample session with fpars</b>
<p>

<p>
<table width="90%"><tr><td bgcolor="#CCFFFF"><pre>

% <b>fpars </b>
Discrete character parsimony
Input file: <b>pars.dat</b>
Input tree file: <b></b>
Output file [pars.fpars]: <b></b>

Adding species:
   1. Alpha     
   2. Beta      
   3. Gamma     
   4. Delta     
   5. Epsilon   

Doing global rearrangements on the first of the trees tied for best
  !---------!
   .........
   .........

Collapsing best trees
   .

Output written to file "pars.fpars"

Tree also written onto file "pars.treefile"

Done.


</pre></td></tr></table><p>
<p>
<a href="#input.1">Go to the input files for this example</a><br><a href="#output.1">Go to the output files for this example</a><p><p>




<H2>
    Command line arguments
</H2>

<table CELLSPACING=0 CELLPADDING=3 BGCOLOR="#f5f5ff" ><tr><td>
<pre>
   Standard (Mandatory) qualifiers:
  [-infile]            discretestates File containing one or more data sets
  [-intreefile]        tree       (no help text) tree value
  [-outfile]           outfile    Output file name

   Additional (Optional) qualifiers (* if not always prompted):
   -weights            properties Weights file
   -method             menu       Choose the parsimony method to use
   -maxtrees           integer    Number of trees to save
*  -[no]thorough       toggle     More thorough search
*  -[no]rearrange      boolean    Rearrange on just one best tree
*  -njumble            integer    Number of times to randomise
*  -seed               integer    Random number seed between 1 and 32767 (must
                                  be odd)
   -outgrno            integer    Species number to use as outgroup
   -thresh             toggle     Use threshold parsimony
*  -threshold          float      Threshold value
   -[no]trout          toggle     Write out trees to tree file
*  -outtreefile        outfile    Tree file name
   -printdata          boolean    Print data at start of run
   -[no]progress       boolean    Print indications of progress of run
   -[no]treeprint      boolean    Print out tree
   -stepbox            boolean    Print steps at each site
   -ancseq             boolean    Print states at all nodes of tree
*  -[no]dotdiff        boolean    Use dot differencing to display results

   Advanced (Unprompted) qualifiers: (none)
   Associated qualifiers:

   "-outfile" associated qualifiers
   -odirectory3        string     Output directory

   "-outtreefile" associated qualifiers
   -odirectory         string     Output directory

   General qualifiers:
   -auto               boolean    Turn off prompts
   -stdout             boolean    Write standard output
   -filter             boolean    Read standard input, write standard output
   -options            boolean    Prompt for standard and additional values
   -debug              boolean    Write debug output to program.dbg
   -verbose            boolean    Report some/full command line options
   -help               boolean    Report command line options. More
                                  information on associated and general
                                  qualifiers can be found with -help -verbose
   -warning            boolean    Report warnings
   -error              boolean    Report errors
   -fatal              boolean    Report fatal errors
   -die                boolean    Report deaths


</pre>
</td></tr></table>
<P>
<table border cellspacing=0 cellpadding=3 bgcolor="#ccccff">
<tr bgcolor="#FFFFCC">
<th align="left" colspan=2>Standard (Mandatory) qualifiers</th>
<th align="left">Allowed values</th>
<th align="left">Default</th>
</tr>

<tr>
<td>[-infile]<br>(Parameter 1)</td>
<td>File containing one or more data sets</td>
<td>Discrete states file</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>[-intreefile]<br>(Parameter 2)</td>
<td>(no help text) tree value</td>
<td>Phylogenetic tree</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>[-outfile]<br>(Parameter 3)</td>
<td>Output file name</td>
<td>Output file</td>
<td><i>&lt;sequence&gt;</i>.fpars</td>
</tr>

<tr bgcolor="#FFFFCC">
<th align="left" colspan=2>Additional (Optional) qualifiers</th>
<th align="left">Allowed values</th>
<th align="left">Default</th>
</tr>

<tr>
<td>-weights</td>
<td>Weights file</td>
<td>Property value(s)</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>-method</td>
<td>Choose the parsimony method to use</td>
<td><table><tr><td>w</td> <td><i>(Wagner)</i></td></tr><tr><td>c</td> <td><i>(Camin-Sokal)</i></td></tr></table></td>
<td>Wagner</td>
</tr>

<tr>
<td>-maxtrees</td>
<td>Number of trees to save</td>
<td>Integer from 1 to 1000000</td>
<td>100</td>
</tr>

<tr>
<td>-[no]thorough</td>
<td>More thorough search</td>
<td>Toggle value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-[no]rearrange</td>
<td>Rearrange on just one best tree</td>
<td>Boolean value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-njumble</td>
<td>Number of times to randomise</td>
<td>Integer 0 or more</td>
<td>0</td>
</tr>

<tr>
<td>-seed</td>
<td>Random number seed between 1 and 32767 (must be odd)</td>
<td>Integer from 1 to 32767</td>
<td>1</td>
</tr>

<tr>
<td>-outgrno</td>
<td>Species number to use as outgroup</td>
<td>Integer 0 or more</td>
<td>0</td>
</tr>

<tr>
<td>-thresh</td>
<td>Use threshold parsimony</td>
<td>Toggle value Yes/No</td>
<td>No</td>
</tr>

<tr>
<td>-threshold</td>
<td>Threshold value</td>
<td>Number 1.000 or more</td>
<td>1</td>
</tr>

<tr>
<td>-[no]trout</td>
<td>Write out trees to tree file</td>
<td>Toggle value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-outtreefile</td>
<td>Tree file name</td>
<td>Output file</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>-printdata</td>
<td>Print data at start of run</td>
<td>Boolean value Yes/No</td>
<td>No</td>
</tr>

<tr>
<td>-[no]progress</td>
<td>Print indications of progress of run</td>
<td>Boolean value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-[no]treeprint</td>
<td>Print out tree</td>
<td>Boolean value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-stepbox</td>
<td>Print steps at each site</td>
<td>Boolean value Yes/No</td>
<td>No</td>
</tr>

<tr>
<td>-ancseq</td>
<td>Print states at all nodes of tree</td>
<td>Boolean value Yes/No</td>
<td>No</td>
</tr>

<tr>
<td>-[no]dotdiff</td>
<td>Use dot differencing to display results</td>
<td>Boolean value Yes/No</td>
<td>Yes</td>
</tr>

<tr bgcolor="#FFFFCC">
<th align="left" colspan=2>Advanced (Unprompted) qualifiers</th>
<th align="left">Allowed values</th>
<th align="left">Default</th>
</tr>

<tr>
<td colspan=4>(none)</td>
</tr>

</table>


<!--
DON'T WRITE ANYTHING HERE.
IT IS DONE FOR YOU.
-->








<H2>
    Input file format
</H2>

<!-- 
        This includes example input file formats.
        This should be a detailed description and example - assume
        someone will want to parse this file and will want to know what
        happens in unusual cases - null input, etc. 
   -->

<b>fpars</b> reads discrete characters input, except that multiple
states (up to 9 of them) are allowed. Any characters other than "?"
are allowed as states, up to a maximum of 9 states. In fact, one can
use different symbols in different columns of the data matrix,
although it is rather unlikely that you would want to do that. The
symbols you can use are:

<ul>

<li>
The digits 0-9, 

<li>
The letters A-Z and a-z, 

<li>
The symbols "!\"#$%&'()*+,-./:;<=>?@\[\\]^_`\{|}~

<p>
(of these, probably only + and - will be of interest to most users). 

</ul>

<p>
But note that these do not include blank (" "). Blanks in the input
data are simply skipped by the program, so that they can be used to
make characters into groups for ease of viewing. The "?" (question
mark) symbol has special meaning. It is allowed in the input but is
not available as the symbol of a state. Rather, it means that the
state is unknown.

<p>
PARS can handle both bifurcating and multifurcating trees. In doing
its search for most parsimonious trees, it adds species not only by
creating new forks in the middle of existing branches, but it also
tries putting them at the end of new branches which are added to
existing forks. Thus it searches among both bifurcating and
multifurcating trees. If a branch in a tree does not have any
characters which might change in that branch in the most parsimonious
tree, it does not save that tree. Thus in any tree that results, a
branch exists only if some character has a most parsimonious
reconstruction that would involve change in that branch.

<p>
It also saves a number of trees tied for best (you can alter the
number it saves using the V option in the menu). When rearranging
trees, it tries rearrangements of all of the saved trees. This makes
the algorithm slower than earlier programs such as MIX.

<h3>(0,1) Discrete character data</h3>

<p>
These programs are intended for the use of morphological
systematists who are dealing with discrete characters, or by molecular
evolutionists dealing with presence-absence data on restriction
sites. One of the programs (PARS) allows multistate characters, with
up to 8 states, plus the unknown state symbol "?". For the others, the
characters are assumed to be coded into a series of (0,1) two-state
characters. For most of the programs there are two other states
possible, "P", which stands for the state of Polymorphism for both
states (0 and 1), and "?", which stands for the state of ignorance: it
is the state "unknown", or "does not apply". The state "P" can also be
denoted by "B", for "both".

<p> There is a method invented by Sokal and Sneath (1963) for linear
sequences of character states, and fully developed for branching
sequences of character states by Kluge and Farris (1969) for recoding
a multistate character into a series of two-state (0,1)
characters. Suppose we had a character with four states whose
character-state tree had the rooted form:

<p>
<pre>
               1 ---> 0 ---> 2
                      |
                      |
                      V
                      3

</pre>

<p>
so that 1 is the ancestral state and 0, 2 and 3 derived states. We
can represent this as three two-state characters:


<p>
<pre>
                Old State           New States
                --- -----           --- ------
                    0                  001
                    1                  000
                    2                  011
                    3                  101

</pre>

<p>
The three new states correspond to the three arrows in the above
character state tree. Possession of one of the new states corresponds
to whether or not the old state had that arrow in its ancestry. Thus
the first new state corresponds to the bottommost arrow, which only
state 3 has in its ancestry, the second state to the rightmost of the
top arrows, and the third state to the leftmost top arrow. This coding
will guarantee that the number of times that states arise on the tree
(in programs MIX, MOVE, PENNY and BOOT) or the number of polymorphic
states in a tree segment (in the Polymorphism option of DOLLOP,
DOLMOVE, DOLPENNY and DOLBOOT) will correctly correspond to what would
have been the case had our programs been able to take multistate
characters into account. Although I have shown the above character
state tree as rooted, the recoding method works equally well on
unrooted multistate characters as long as the connections between the
states are known and contain no loops.

<p>
However, in the default option of programs DOLLOP, DOLMOVE,
DOLPENNY and DOLBOOT the multistate recoding does not necessarily work
properly, as it may lead the program to reconstruct nonexistent state
combinations such as 010. An example of this problem is given in my
paper on alternative phylogenetic methods (1979).

<p>
If you have multistate character data where the states are connected
in a branching "character state tree" you may want to do the binary
recoding yourself. Thanks to Christopher Meacham, the package contains
a program, FACTOR, which will do the recoding itself. For details see
the documentation file for FACTOR.

<p>
We now also have the program PARS, which can do parsimony for
unordered character states.




<p>


<a name="input.1"></a>
<h3>Input files for usage example </h3>
<p><h3>File: pars.dat</h3>
<table width="90%"><tr><td bgcolor="#FFCCFF">
<pre>
     5    6
Alpha     110110
Beta      110000
Gamma     100110
Delta     001001
Epsilon   001110
</pre>
</td></tr></table><p>






<H2>
    Output file format
</H2>

<!-- 
        This includes example output file formats.
        This should be a detailed description and example - assume
        someone will want to parse this file and will want to know what
        happens in unusual cases - null output, errors etc. 
        If you wish to include the standard description of the avalable
	report formats, use:
include file="inc/reportformats.ihtml"
   -->

<b>fpars</b> output is standard: if option 1 is toggled on, the data is
printed out, with the convention that "." means "the same as in the
first species". Then comes a list of equally parsimonious trees. Each
tree has branch lengths. These are computed using an algorithm
published by Hochbaum and Pathria (1997) which I first heard of from
Wayne Maddison who invented it independently of them. This algorithm
averages the number of reconstructed changes of state over all sites a
over all possible most parsimonious placements of the changes of state
among branches. Note that it does not correct in any way for multiple
changes that overlay each other.

<p>
If option 2 is toggled on a table of the number of changes of state
required in each character is also printed. If option 5 is toggled on,
a table is printed out after each tree, showing for each branch
whether there are known to be changes in the branch, and what the
states are inferred to have been at the top end of the branch. This is
a reconstruction of the ancestral sequences in the tree. If you choose
option 5, a menu item D appears which gives you the opportunity to
turn off dot-differencing so that complete ancestral sequences are
shown. If the inferred state is a "?", there will be multiple
equally-parsimonious assignments of states; the user must work these
out for themselves by hand. If option 6 is left in its default state
the trees found will be written to a tree file, so that they are
available to be used in other programs. If the program finds multiple
trees tied for best, all of these are written out onto the output tree
file. Each is followed by a numerical weight in square brackets (such
as [0.25000]). This is needed when we use the trees to make a
consensus tree of the results of bootstrapping or jackknifing, to
avoid overrepresenting replicates that find many tied trees.

<p>
If the U (User Tree) option is used and more than one tree is
supplied, the program also performs a statistical test of each of
these trees against the best tree. This test, which is a version of
the test proposed by Alan Templeton (1983) and evaluated in a test
case by me (1985a). It is closely parallel to a test using log
likelihood differences due to Kishino and Hasegawa (1989), and uses
the mean and variance of step differences between trees, taken across
sites. If the mean is more than 1.96 standard deviations different
then the trees are declared significantly different. The program
prints out a table of the steps for each tree, the differences of each
from the best one, the variance of that quantity as determined by the
step differences at individual sites, and a conclusion as to whether
that tree is or is not significantly worse than the best one. It is
important to understand that the test assumes that all the discrete
characters are evolving independently, which is unlikely to be true
for


<p>
If there are more than two trees, the test done is an extension of the
KHT test, due to Shimodaira and Hasegawa (1999). They pointed out that
a correction for the number of trees was necessary, and they
introduced a resampling method to make this correction. In the version
used here the variances and covariances of the sums of steps across
characters are computed for all pairs of trees. To test whether the
difference between each tree and the best one is larger than could
have been expected if they all had the same expected number of steps,
numbers of steps for all trees are sampled with these covariances and
equal means (Shimodaira and Hasegawa's "least favorable hypothesis"),
and a P value is computed from the fraction of times the difference
between the tree's value and the lowest number of steps exceeds that
actually observed. Note that this sampling needs random numbers, and
so the program will prompt the user for a random number seed if one
has not already been supplied. With the two-tree KHT test no random
numbers are used.

<p>
In either the KHT or the SH test the program prints out a table of the
number of steps for each tree, the differences of each from the lowest
one, the variance of that quantity as determined by the differences of
the numbers of steps at individual characters, and a conclusion as to
whether that tree is or is not significantly worse than the best one.

<p>
Option 6 in the menu controls whether the tree estimated by the
program is written onto a tree file. The default name of this output
tree file is "outtree". If the U option is in effect, all the
user-defined trees are written to the output tree file.



<p>


<a name="output.1"></a>
<h3>Output files for usage example </h3>
<p><h3>File: pars.fpars</h3>
<table width="90%"><tr><td bgcolor="#CCFFCC">
<pre>

Discrete character parsimony algorithm, version 3.6b


One most parsimonious tree found:


                            +Epsilon   
           +----------------3  
  +--------2                +-------------------------Delta     
  |        |  
  |        +Gamma     
  |  
  1----------------Beta      
  |  
  +Alpha     


requires a total of      8.000

  between      and       length
  -------      ---       ------
     1           2         1.00
     2           3         2.00
     3      Epsilon        0.00
     3      Delta          3.00
     2      Gamma          0.00
     1      Beta           2.00
     1      Alpha          0.00

</pre>
</td></tr></table><p>
<p><h3>File: pars.treefile</h3>
<table width="90%"><tr><td bgcolor="#CCFFCC">
<pre>
(((Epsilon:0.00,Delta:3.00):2.00,Gamma:0.00):1.00,Beta:2.00,Alpha:0.00);
</pre>
</td></tr></table><p>






<H2>
    Data files
</H2>

None

<H2>
    Notes
</H2>

<!-- 
        Restrictions.
        Interesting behaviour.
        Useful things you can do with this program.
   -->

None.







<H2>
    References
</H2>

<!-- 
        Bibliography for methods used.
   -->

None.








<H2>
    Warnings
</H2>

<!-- 
        Potentially stupid things the program will let you do.
   -->

None.







<H2>
    Diagnostic Error Messages
</H2>

<!-- 
        Error messages specific to this program, eg:
        "FATAL xxx" - means you have not set up the xxx data using program <b>prog</b>.<p>
   -->

None.







<H2>
    Exit status
</H2>

<!-- 
        Description of the exit status for various error conditions
   -->

It always exits with status 0.








<H2>
    Known bugs
</H2>


<!-- 
        Bugs noted but not yet fixed.
   -->

None.








<!--
<H2>
    See also
</H2>
-->
<h2><a name="See also">See also</a></h2>
<table border cellpadding=4 bgcolor="#FFFFF0">
<tr><th>Program name</th><th>Description</th></tr>
<tr><td><a href="../phylip/eclique.html">eclique</a></td><td>Largest clique program</td></tr>
<tr><td><a href="../phylip/edollop.html">edollop</a></td><td>Dollo and polymorphism parsimony algorithm</td></tr>
<tr><td><a href="../phylip/edolpenny.html">edolpenny</a></td><td>Penny algorithm Dollo or polymorphism</td></tr>
<tr><td><a href="../phylip/efactor.html">efactor</a></td><td>Multistate to binary recoding program</td></tr>
<tr><td><a href="../phylip/emix.html">emix</a></td><td>Mixed parsimony algorithm</td></tr>
<tr><td><a href="../phylip/epenny.html">epenny</a></td><td>Penny algorithm, branch-and-bound</td></tr>
<tr><td><a href="fclique.html">fclique</a></td><td>Largest clique program</td></tr>
<tr><td><a href="fdollop.html">fdollop</a></td><td>Dollo and polymorphism parsimony algorithm</td></tr>
<tr><td><a href="fdolpenny.html">fdolpenny</a></td><td>Penny algorithm Dollo or polymorphism</td></tr>
<tr><td><a href="ffactor.html">ffactor</a></td><td>Multistate to binary recoding program</td></tr>
<tr><td><a href="fmix.html">fmix</a></td><td>Mixed parsimony algorithm</td></tr>
<tr><td><a href="fmove.html">fmove</a></td><td>Interactive mixed method parsimony</td></tr>
<tr><td><a href="fpenny.html">fpenny</a></td><td>Penny algorithm, branch-and-bound</td></tr>
</table>

<!-- 
        Add any comments about other associated programs (to prepare
        data files?) that seealso doesn't find. 
   -->










<H2>
    Author(s)
</H2>

This program is an EMBOSS conversion of a program written by Joe
Felsenstein as part of his PHYLIP package.

<p>
Although we take every care to ensure that the results of the EMBOSS
version are identical to those from the original package, we recommend
that you check your inputs give the same results in both versions
before publication.

<p>
Please report all bugs in the EMBOSS version to the EMBOSS bug team,
not to the original author.


<H2>
    History
</H2>

Written (2004) - Joe Felsenstein, University of Washington.
<p>
Converted (August 2004) to an EMBASSY program by the EMBOSS team.




<H2>
    Target users
</H2>

<!--
        For general users, requested by one user, for EMBOSS site
        maintainers, for EMBOSS developers etc.
        eg:
        "This program is intended to be used by everyone and everything,
        from naive users to embedded scripts." 
	Which is easy to include using:
   -->

This program is intended to be used by everyone and everything, from naive users to embedded scripts.












</BODY>
</HTML>

