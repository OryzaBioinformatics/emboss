<!--START OF HEADER - DON'T ALTER -->

<HTML>
<HEAD>
  <TITLE>
  EMBOSS: fdnapars
  </TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" text="#000000">



<table align=center border=0 cellspacing=0 cellpadding=0>
<tr><td valign=top>
<A HREF="/" ONMOUSEOVER="self.status='Go to the EMBOSS home page';return true"><img border=0 src="emboss_icon.jpg" alt="" width=150 height=48></a>
</td>
<td align=left valign=middle>
<b><font size="+6">

fdnapars
</font></b>
</td></tr>
</table>
<br>&nbsp;
<p>



<!--END OF HEADER-->






<H2>
    Function
</H2>
DNA parsimony algorithm

<!--
DON'T WRITE ANYTHING HERE.
IT IS DONE FOR YOU.
-->




<H2>
    Description
</H2>


Estimates phylogenies by the parsimony method using nucleic acid
sequences. Allows use the full IUB ambiguity codes, and estimates
ancestral nucleotide states. Gaps treated as a fifth nucleotide
state. It can also fo transversion parsimony. Can cope with
multifurcations, reconstruct ancestral states, use 0/1 character
weights, and infer branch lengths

<H2>
    Algorithm
</H2>


This program carries out unrooted parsimony (analogous to Wagner
trees) (Eck and Dayhoff, 1966; Kluge and Farris, 1969) on DNA
sequences. The method of Fitch (1971) is used to count the number of
changes of base needed on a given tree. The assumptions of this method
are analogous to those of MIX:

<ol>

<li>
Each site evolves independently.

<li>
Different lineages evolve independently.

<li>
The probability of a base substitution at a given site
is small over the lengths of time involved in a branch of the
phylogeny.

<li>
The expected amounts of change in different branches of
the phylogeny do not vary by so much that two changes in a high-rate
branch are more probable than one change in a low-rate branch.

<li>
The expected amounts of change do not vary enough among sites that two
changes in one site are more probable than one change in another.

</ol>


<p>
That these are the assumptions of parsimony methods has been
documented in a series of papers of mine: (1973a, 1978b, 1979, 1981b,
1983b, 1988b). For an opposing view arguing that the parsimony methods
make no substantive assumptions such as these, see the papers by
Farris (1983) and Sober (1983a, 1983b, 1988), but also read the
exchange between Felsenstein and Sober (1986).

<p>
Change from an occupied site to a deletion is counted as one
change. Reversion from a deletion to an occupied site is allowed and
is also counted as one change. Note that this in effect assumes that a
deletion N bases long is N separate events.

<p>
Dnapars can handle both bifurcating and multifurcating trees. In doing
its search for most parsimonious trees, it adds species not only by
creating new forks in the middle of existing branches, but it also
tries putting them at the end of new branches which are added to
existing forks. Thus it searches among both bifurcating and
multifurcating trees. If a branch in a tree does not have any
characters which might change in that branch in the most parsimonious
tree, it does not save that tree. Thus in any tree that results, a
branch exists only if some character has a most parsimonious
reconstruction that would involve change in that branch.

It also saves a number of trees tied for best (you can alter the
<p>
number it saves using the V option in the menu). When rearranging
trees, it tries rearrangements of all of the saved trees. This makes
the algorithm slower than earlier versions of Dnapars.

<p>
The input data is standard. The first line of the input file contains
the number of species and the number of sites.

<p>
Next come the species data. Each sequence starts on a new line, has a
ten-character species name that must be blank-filled to be of that
length, followed immediately by the species data in the one-letter
code. The sequences must either be in the "interleaved" or
"sequential" formats described in the Molecular Sequence Programs
document. The I option selects between them. The sequences can have
internal blanks in the sequence but there must be no extra blanks at
the end of the terminated line. Note that a blank is not a valid
symbol for a deletion.


<H2>
    Usage
</H2>

<!--  
	Example usage, as run from the command-line.
        Many examples illustrating different behaviours is good.
 -->

<b>Here is a sample session with fdnapars</b>
<p>

<p>
<table width="90%"><tr><td bgcolor="#CCFFFF"><pre>

% <b>fdnapars </b>
DNA parsimony algorithm
Input sequence: <b>dnapars.dat</b>
Input tree file: <b></b>
Output file [dnapars.fdnapars]: <b></b>

Adding species:
   1. Alpha     
   2. Beta      
   3. Gamma     
   4. Delta     
   5. Epsilon   

Doing global rearrangements on the first of the trees tied for best
  !---------!
   .........
   .........

Collapsing best trees
   .

Output written to file "dnapars.fdnapars"

Tree also written onto file "dnapars.treefile"

Done.


</pre></td></tr></table><p>
<p>
<a href="#input.1">Go to the input files for this example</a><br><a href="#output.1">Go to the output files for this example</a><p><p>




<H2>
    Command line arguments
</H2>

<table CELLSPACING=0 CELLPADDING=3 BGCOLOR="#f5f5ff" ><tr><td>
<pre>
   Standard (Mandatory) qualifiers:
  [-sequence]          seqsetall  File containing one or more sequence
                                  alignments
  [-intreefile]        tree       (no help text) tree value
  [-outfile]           outfile    Output file name

   Additional (Optional) qualifiers (* if not always prompted):
   -weights            properties Weights file
   -maxtrees           integer    Number of trees to save
*  -[no]thorough       toggle     More thorough search
*  -[no]rearrange      boolean    Rearrange on just one best tree
   -transversion       boolean    Use transversion parsimony
*  -njumble            integer    Number of times to randomise
*  -seed               integer    Random number seed between 1 and 32767 (must
                                  be odd)
   -outgrno            integer    Species number to use as outgroup
   -thresh             toggle     Use threshold parsimony
*  -threshold          float      Threshold value
   -[no]trout          toggle     Write out trees to tree file
*  -outtreefile        outfile    Tree file name
   -printdata          boolean    Print data at start of run
   -[no]progress       boolean    Print indications of progress of run
   -stepbox            boolean    Print out steps in each site
   -ancseq             boolean    Print sequences at all nodes of tree
   -[no]treeprint      boolean    Print out tree
*  -[no]dotdiff        boolean    Use dot differencing to display results

   Advanced (Unprompted) qualifiers: (none)
   Associated qualifiers:

   "-sequence" associated qualifiers
   -sbegin1            integer    Start of each sequence to be used
   -send1              integer    End of each sequence to be used
   -sreverse1          boolean    Reverse (if DNA)
   -sask1              boolean    Ask for begin/end/reverse
   -snucleotide1       boolean    Sequence is nucleotide
   -sprotein1          boolean    Sequence is protein
   -slower1            boolean    Make lower case
   -supper1            boolean    Make upper case
   -sformat1           string     Input sequence format
   -sdbname1           string     Database name
   -sid1               string     Entryname
   -ufo1               string     UFO features
   -fformat1           string     Features format
   -fopenfile1         string     Features file name

   "-outfile" associated qualifiers
   -odirectory3        string     Output directory

   "-outtreefile" associated qualifiers
   -odirectory         string     Output directory

   General qualifiers:
   -auto               boolean    Turn off prompts
   -stdout             boolean    Write standard output
   -filter             boolean    Read standard input, write standard output
   -options            boolean    Prompt for standard and additional values
   -debug              boolean    Write debug output to program.dbg
   -verbose            boolean    Report some/full command line options
   -help               boolean    Report command line options. More
                                  information on associated and general
                                  qualifiers can be found with -help -verbose
   -warning            boolean    Report warnings
   -error              boolean    Report errors
   -fatal              boolean    Report fatal errors
   -die                boolean    Report deaths


</pre>
</td></tr></table>
<P>
<table border cellspacing=0 cellpadding=3 bgcolor="#ccccff">
<tr bgcolor="#FFFFCC">
<th align="left" colspan=2>Standard (Mandatory) qualifiers</th>
<th align="left">Allowed values</th>
<th align="left">Default</th>
</tr>

<tr>
<td>[-sequence]<br>(Parameter 1)</td>
<td>File containing one or more sequence alignments</td>
<td>Readable sets of sequences</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>[-intreefile]<br>(Parameter 2)</td>
<td>(no help text) tree value</td>
<td>Phylogenetic tree</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>[-outfile]<br>(Parameter 3)</td>
<td>Output file name</td>
<td>Output file</td>
<td><i>&lt;sequence&gt;</i>.fdnapars</td>
</tr>

<tr bgcolor="#FFFFCC">
<th align="left" colspan=2>Additional (Optional) qualifiers</th>
<th align="left">Allowed values</th>
<th align="left">Default</th>
</tr>

<tr>
<td>-weights</td>
<td>Weights file</td>
<td>Property value(s)</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>-maxtrees</td>
<td>Number of trees to save</td>
<td>Integer from 1 to 1000000</td>
<td>10000</td>
</tr>

<tr>
<td>-[no]thorough</td>
<td>More thorough search</td>
<td>Toggle value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-[no]rearrange</td>
<td>Rearrange on just one best tree</td>
<td>Boolean value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-transversion</td>
<td>Use transversion parsimony</td>
<td>Boolean value Yes/No</td>
<td>No</td>
</tr>

<tr>
<td>-njumble</td>
<td>Number of times to randomise</td>
<td>Integer 0 or more</td>
<td>0</td>
</tr>

<tr>
<td>-seed</td>
<td>Random number seed between 1 and 32767 (must be odd)</td>
<td>Integer from 1 to 32767</td>
<td>1</td>
</tr>

<tr>
<td>-outgrno</td>
<td>Species number to use as outgroup</td>
<td>Integer 0 or more</td>
<td>0</td>
</tr>

<tr>
<td>-thresh</td>
<td>Use threshold parsimony</td>
<td>Toggle value Yes/No</td>
<td>No</td>
</tr>

<tr>
<td>-threshold</td>
<td>Threshold value</td>
<td>Number 1.000 or more</td>
<td>1.0</td>
</tr>

<tr>
<td>-[no]trout</td>
<td>Write out trees to tree file</td>
<td>Toggle value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-outtreefile</td>
<td>Tree file name</td>
<td>Output file</td>
<td>&nbsp;</td>
</tr>

<tr>
<td>-printdata</td>
<td>Print data at start of run</td>
<td>Boolean value Yes/No</td>
<td>No</td>
</tr>

<tr>
<td>-[no]progress</td>
<td>Print indications of progress of run</td>
<td>Boolean value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-stepbox</td>
<td>Print out steps in each site</td>
<td>Boolean value Yes/No</td>
<td>No</td>
</tr>

<tr>
<td>-ancseq</td>
<td>Print sequences at all nodes of tree</td>
<td>Boolean value Yes/No</td>
<td>No</td>
</tr>

<tr>
<td>-[no]treeprint</td>
<td>Print out tree</td>
<td>Boolean value Yes/No</td>
<td>Yes</td>
</tr>

<tr>
<td>-[no]dotdiff</td>
<td>Use dot differencing to display results</td>
<td>Boolean value Yes/No</td>
<td>Yes</td>
</tr>

<tr bgcolor="#FFFFCC">
<th align="left" colspan=2>Advanced (Unprompted) qualifiers</th>
<th align="left">Allowed values</th>
<th align="left">Default</th>
</tr>

<tr>
<td colspan=4>(none)</td>
</tr>

</table>


<!--
DON'T WRITE ANYTHING HERE.
IT IS DONE FOR YOU.
-->








<H2>
    Input file format
</H2>

<!-- 
        This includes example input file formats.
        This should be a detailed description and example - assume
        someone will want to parse this file and will want to know what
        happens in unusual cases - null input, etc. 
   -->

<b>fdnapars</b> reads any normal sequence USAs.

<p>


<a name="input.1"></a>
<h3>Input files for usage example </h3>
<p><h3>File: dnapars.dat</h3>
<table width="90%"><tr><td bgcolor="#FFCCFF">
<pre>
   5   13
Alpha     AACGUGGCCAAAU
Beta      AAGGUCGCCAAAC
Gamma     CAUUUCGUCACAA
Delta     GGUAUUUCGGCCU
Epsilon   GGGAUCUCGGCCC
</pre>
</td></tr></table><p>






<H2>
    Output file format
</H2>

<!-- 
        This includes example output file formats.
        This should be a detailed description and example - assume
        someone will want to parse this file and will want to know what
        happens in unusual cases - null output, errors etc. 

        If you wish to include the standard description of the avalable
	report formats, use:
include file="inc/reportformats.ihtml"
   -->

<b>fdnapars</b> output is standard: if option 1 is toggled on, the
data is printed out, with the convention that "." means "the same as
in the first species". Then comes a list of equally parsimonious
trees. Each tree has branch lengths. These are computed using an
algorithm published by Hochbaum and Pathria (1997) which I first heard
of from Wayne Maddison who invented it independently of them. This
algorithm averages the number of reconstructed changes of state over
all sites a over all possible most parsimonious placements of the
changes of state among branches. Note that it does not correct in any
way for multiple changes that overlay each other.

If option 2 is toggled on a table of the number of changes of state
required in each character is also printed. If option 5 is toggled on,
a table is printed out after each tree, showing for each branch
whether there are known to be changes in the branch, and what the
states are inferred to have been at the top end of the branch. This is
a reconstruction of the ancestral sequences in the tree. If you choose
option 5, a menu item "." appears which gives you the opportunity to
turn off dot-differencing so that complete ancestral sequences are
shown. If the inferred state is a "?" or one of the IUB ambiguity
symbols, there will be multiple equally-parsimonious assignments of
states; the user must work these out for themselves by hand. A "?" in
the reconstructed states means that in addition to one or more bases,
a deletion may or may not be present. If option 6 is left in its
default state the trees found will be written to a tree file, so that
they are available to be used in other programs.

If the U (User Tree) option is used and more than one tree is
supplied, the program also performs a statistical test of each of
these trees against the best tree. This test, which is a version of
the test proposed by Alan Templeton (1983) and evaluated in a test
case by me (1985a). It is closely parallel to a test using log
likelihood differences due to Kishino and Hasegawa (1989), and uses
the mean and variance of step differences between trees, taken across
sites. If the mean is more than 1.96 standard deviations different
then the trees are declared significantly different. The program
prints out a table of the steps for each tree, the differences of each
from the best one, the variance of that quantity as determined by the
step differences at individual sites, and a conclusion as to whether
that tree is or is not significantly worse than the best one. If the U
(User Tree) option is used and more than one tree is supplied, and the
program is not told to assume autocorrelation between the rates at
different sites, the program also performs a statistical test of each
of these trees against the one with highest likelihood. If there are
two user trees, this is a version of the test proposed by Alan
Templeton (1983) and evaluated in a test case by me (1985a). It is
closely parallel to a test using log likelihood differences due to
Kishino and Hasegawa (1989) It uses the mean and variance of the
differences in the number of steps between trees, taken across
sites. If the two trees' means are more than 1.96 standard deviations
different, then the trees are declared significantly different.

If there are more than two trees, the test done is an extension of the
KHT test, due to Shimodaira and Hasegawa (1999). They pointed out that
a correction for the number of trees was necessary, and they
introduced a resampling method to make this correction. In the version
used here the variances and covariances of the sums of steps across
sites are computed for all pairs of trees. To test whether the
difference between each tree and the best one is larger than could
have been expected if they all had the same expected number of steps,
numbers of steps for all trees are sampled with these covariances and
equal means (Shimodaira and Hasegawa's "least favorable hypothesis"),
and a P value is computed from the fraction of times the difference
between the tree's value and the lowest number of steps exceeds that
actually observed. Note that this sampling needs random numbers, and
so the program will prompt the user for a random number seed if one
has not already been supplied. With the two-tree KHT test no random
numbers are used.

In either the KHT or the SH test the program prints out a table of the
number of steps for each tree, the differences of each from the lowest
one, the variance of that quantity as determined by the differences of
the numbers of steps at individual sites, and a conclusion as to
whether that tree is or is not significantly worse than the best one.

Option 6 in the menu controls whether the tree estimated by the
program is written onto a tree file. The default name of this output
tree file is "outtree". If the U option is in effect, all the
user-defined trees are written to the output tree file. If the program
finds multiple trees tied for best, all of these are written out onto
the output tree file. Each is followed by a numerical weight in square
brackets (such as [0.25000]). This is needed when we use the trees to
make a consensus tree of the results of bootstrapping or jackknifing,
to avoid overrepresenting replicates that find many tied trees.

<p>


<a name="output.1"></a>
<h3>Output files for usage example </h3>
<p><h3>File: dnapars.fdnapars</h3>
<table width="90%"><tr><td bgcolor="#CCFFCC">
<pre>

DNA parsimony algorithm, version 3.6b


One most parsimonious tree found:


                                            +-----Epsilon   
               +----------------------------3  
  +------------2                            +-------Delta     
  |            |  
  |            +----------------Gamma     
  |  
  1----Beta      
  |  
  +---------Alpha     


requires a total of     19.000

  between      and       length
  -------      ---       ------
     1           2       0.217949
     2           3       0.487179
     3      Epsilon      0.096154
     3      Delta        0.134615
     2      Gamma        0.275641
     1      Beta         0.076923
     1      Alpha        0.173077

</pre>
</td></tr></table><p>
<p><h3>File: dnapars.treefile</h3>
<table width="90%"><tr><td bgcolor="#CCFFCC">
<pre>
(((Epsilon:0.09615,Delta:0.13462):0.48718,Gamma:0.27564):0.21795,
Beta:0.07692,Alpha:0.17308);
</pre>
</td></tr></table><p>






<H2>
    Data files
</H2>

None

<H2>
    Notes
</H2>

<!-- 
        Restrictions.
        Interesting behaviour.
        Useful things you can do with this program.
   -->

None.







<H2>
    References
</H2>

<!-- 
        Bibliography for methods used.
   -->

None.








<H2>
    Warnings
</H2>

<!-- 
        Potentially stupid things the program will let you do.
   -->

None.







<H2>
    Diagnostic Error Messages
</H2>

<!-- 
        Error messages specific to this program, eg:
        "FATAL xxx" - means you have not set up the xxx data using program <b>prog</b>.<p>
   -->

None.







<H2>
    Exit status
</H2>

<!-- 
        Description of the exit status for various error conditions
   -->

It always exits with status 0.








<H2>
    Known bugs
</H2>


<!-- 
        Bugs noted but not yet fixed.
   -->

None.








<!--
<H2>
    See also
</H2>
-->
<h2><a name="See also">See also</a></h2>
<table border cellpadding=4 bgcolor="#FFFFF0">
<tr><th>Program name</th><th>Description</th></tr>
<tr><td><a href="../phylip/ednacomp.html">ednacomp</a></td><td>DNA compatibility algorithm</td></tr>
<tr><td><a href="../phylip/ednadist.html">ednadist</a></td><td>Nucleic acid sequence Distance Matrix program</td></tr>
<tr><td><a href="../phylip/ednainvar.html">ednainvar</a></td><td>Nucleic acid sequence Invariants method</td></tr>
<tr><td><a href="../phylip/ednaml.html">ednaml</a></td><td>Phylogenies from nucleic acid Maximum Likelihood</td></tr>
<tr><td><a href="../phylip/ednamlk.html">ednamlk</a></td><td>Phylogenies from nucleic acid Maximum Likelihood with clock</td></tr>
<tr><td><a href="../phylip/ednapars.html">ednapars</a></td><td>DNA parsimony algorithm</td></tr>
<tr><td><a href="../phylip/ednapenny.html">ednapenny</a></td><td>Penny algorithm for DNA</td></tr>
<tr><td><a href="../phylip/eprotdist.html">eprotdist</a></td><td>Protein distance algorithm</td></tr>
<tr><td><a href="../phylip/eprotpars.html">eprotpars</a></td><td>Protein parsimony algorithm</td></tr>
<tr><td><a href="../phylip/erestml.html">erestml</a></td><td>Restriction site Maximum Likelihood method</td></tr>
<tr><td><a href="../phylip/eseqboot.html">eseqboot</a></td><td>Bootstrapped sequences algorithm</td></tr>
<tr><td><a href="fdiscboot.html">fdiscboot</a></td><td>Bootstrapped discrete sites algorithm</td></tr>
<tr><td><a href="fdnacomp.html">fdnacomp</a></td><td>DNA compatibility algorithm</td></tr>
<tr><td><a href="fdnadist.html">fdnadist</a></td><td>Nucleic acid sequence Distance Matrix program</td></tr>
<tr><td><a href="fdnainvar.html">fdnainvar</a></td><td>Nucleic acid sequence Invariants method</td></tr>
<tr><td><a href="fdnaml.html">fdnaml</a></td><td>Estimates nucleotide phylogeny by maximum likelihood</td></tr>
<tr><td><a href="fdnamlk.html">fdnamlk</a></td><td>Estimates nucleotide phylogeny by maximum likelihood</td></tr>
<tr><td><a href="fdnamove.html">fdnamove</a></td><td>Interactive DNA parsimony</td></tr>
<tr><td><a href="fdnapenny.html">fdnapenny</a></td><td>Penny algorithm for DNA</td></tr>
<tr><td><a href="fdolmove.html">fdolmove</a></td><td>Interactive Dollo or Polymorphism Parsimony</td></tr>
<tr><td><a href="ffreqboot.html">ffreqboot</a></td><td>Bootstrapped genetic frequencies algorithm</td></tr>
<tr><td><a href="fproml.html">fproml</a></td><td>Protein phylogeny by maximum likelihood</td></tr>
<tr><td><a href="fpromlk.html">fpromlk</a></td><td>Protein phylogeny by maximum likelihood</td></tr>
<tr><td><a href="fprotdist.html">fprotdist</a></td><td>Protein distance algorithm</td></tr>
<tr><td><a href="fprotpars.html">fprotpars</a></td><td>Protein pasimony algorithm</td></tr>
<tr><td><a href="frestboot.html">frestboot</a></td><td>Bootstrapped restriction sites algorithm</td></tr>
<tr><td><a href="frestdist.html">frestdist</a></td><td>Distance matrix from restriction sites or fragments</td></tr>
<tr><td><a href="frestml.html">frestml</a></td><td>Restriction site maximum Likelihood method</td></tr>
<tr><td><a href="fseqboot.html">fseqboot</a></td><td>Bootstrapped sequences algorithm</td></tr>
<tr><td><a href="fseqbootall.html">fseqbootall</a></td><td>Bootstrapped sequences algorithm</td></tr>
</table>

<!-- 
        Add any comments about other associated programs (to prepare
        data files?) that seealso doesn't find. 
   -->










<H2>
    Author(s)
</H2>

This program is an EMBOSS conversion of a program written by Joe
Felsenstein as part of his PHYLIP package.

<p>
Although we take every care to ensure that the results of the EMBOSS
version are identical to those from the original package, we recommend
that you check your inputs give the same results in both versions
before publication.

<p>
Please report all bugs in the EMBOSS version to the EMBOSS bug team,
not to the original author.


<H2>
    History
</H2>

Written (2004) - Joe Felsenstein, University of Washington.
<p>
Converted (August 2004) to an EMBASSY program by the EMBOSS team.




<H2>
    Target users
</H2>

<!--
        For general users, requested by one user, for EMBOSS site
        maintainers, for EMBOSS developers etc.
        eg:
        "This program is intended to be used by everyone and everything,
        from naive users to embedded scripts." 
	Which is easy to include using:
   -->

This program is intended to be used by everyone and everything, from naive users to embedded scripts.












</BODY>
</HTML>

